// Generated by CoffeeScript 1.3.3
(function() {
  var Generator, bundleGenerator, colors, createDir, exec, fs, path, projectGenerator, sendCommand, spawn, sys, util, utils, _ref,
    __slice = [].slice;

  fs = require('fs');

  util = require('util');

  path = require('path');

  sys = require('sys');

  _ref = require('child_process'), spawn = _ref.spawn, exec = _ref.exec;

  colors = require('colors');

  exports.VERSION = '0.1.06';

  Generator = {
    collection: {},
    addGenerator: function(name, callback) {
      return this.collection[name] = callback;
    },
    exists: function(name) {
      return !!this.collection[name];
    },
    "do": function() {
      var args, name, _ref1;
      name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return (_ref1 = this.collection)[name].apply(_ref1, args);
    },
    list: function() {
      return Object.keys(this.collection).join(', ');
    },
    init: function() {
      this.addGenerator('project', projectGenerator);
      return this.addGenerator('bundle', bundleGenerator);
    }
  };

  projectGenerator = function(command, args) {
    switch (command) {
      case "create":
        utils.timeLog('Cloning based project layout...');
        return sendCommand("git clone https://github.com/cordjs/cordjs.git .", function() {
          createDir('public/bundles/cord');
          createDir('public/bundles/cord/core');
          utils.timeLog('Cloning core...');
          return sendCommand("git clone https://github.com/cordjs/core.git public/bundles/cord/core");
        });
      case "update":
        if (!fs.existsSync('public')) {
          return utils.timeLogError('Can\'t find public!');
        }
        utils.timeLog('Update based project layout...');
        return sendCommand("git pull", function() {
          if (!fs.existsSync('public/bundles/cord/core')) {
            return utils.timeLogError('Can\'t find cord/core!');
          }
          utils.timeLog('Update core...');
          return sendCommand("cd public/bundles/cord; git pull; cd -", function() {});
        });
    }
  };

  bundleGenerator = function(command, args) {
    var bundleName;
    switch (command) {
      case "create":
        bundleName = args.shift();
        if (!bundleName) {
          utils.timeLogError('Empty bandle name');
          process.exit();
        }
        createDir(path.join("public/bundles", bundleName));
        return utils.timeLog("Bundle " + bundleName + " create!");
    }
  };

  Generator.init();

  exports.Generator = Generator;

  createDir = function(dir) {
    var pathDir, root;
    root = process.cwd();
    pathDir = path.join(root, dir);
    if (!fs.existsSync(pathDir)) {
      return fs.mkdirSync(path.join(root, dir), '0755');
    }
  };

  sendCommand = function(command, callback) {
    return exec(command, function(error, stdout, stderr) {
      if (error) {
        utils.timeLogError("" + error);
      } else {
        if (stdout) {
          utils.timeLog(stdout);
        }
      }
      return typeof callback === "function" ? callback.apply(null, arguments) : void 0;
    });
  };

  exports.sendCommand = sendCommand;

  utils = {
    time: (new Date).toLocaleTimeString(),
    timeLog: function(message) {
      return console.log("" + utils.time + " - " + message);
    },
    timeLogError: function(message, text) {
      if (text == null) {
        text = '';
      }
      return console.log(("" + utils.time + " - ").red + ("" + (utils.textError(message)) + " " + text));
    },
    logError: function(message) {
      return console.log(utils.textError(message));
    },
    textError: function(message) {
      return ("" + 'ERROR:'.bold + " " + message).red;
    }
  };

  exports.utils = utils;

}).call(this);
