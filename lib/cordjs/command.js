// Generated by CoffeeScript 1.3.3
(function() {
  var Cordjs, EmptyArguments, OptionsList, baseDirFull, compileWidget, copyFile, counters, create, createDir, exec, exists, fs, getWidgetPath, hidden, isDiffSource, mainCommand, options, optparse, otherCommand, outputDir, outputPath, parseOptions, path, pathToCore, pathToNodeInit, printLine, printWarn, publicDir, removeDirSync, removeSource, requirejs, restartServer, serverChild, sources, spawn, startServer, stopServer, syncFile, syncFiles, testCommandDir, timeEnd, timeStart, unwatchDir, usage, util, version, wait, walk, watchDir, watchFile, widgetsWaitComliler, _endTimer, _ref, _startTimer;

  fs = require('fs');

  util = require('util');

  path = require('path');

  walk = require('walk');

  optparse = require('./optparse');

  _ref = require('child_process'), spawn = _ref.spawn, exec = _ref.exec;

  Cordjs = require('./cordjs');

  util = require('util');

  requirejs = require('requirejs');

  publicDir = 'public';

  outputDir = 'target';

  options = {};

  sources = [];

  widgetsWaitComliler = [];

  counters = {
    syncFiles: 0,
    copiesFiles: 0
  };

  baseDirFull = null;

  serverChild = null;

  pathToCore = "/bundles/cord/core/";

  pathToNodeInit = "" + pathToCore + "nodeInit";

  EmptyArguments = (" " + 'Usage:'.bold + " cordjs [options] path/to/project -- [args] ").inverse;

  OptionsList = [['-a', '--autorestart', 'autorestart server'], ['-b', '--build', 'build project'], ['-c', '--clean', 'clean target'], ['-d', '--dev', 'development mode - copy all files to the outputDir'], ['-h', '--help', 'display this help message'], ['-o', '--output [DIR]', 'output directory'], ['-s', '--server', 'start server'], ['-v', '--version', 'display the version number'], ['-w', '--watch', 'watch scripts for changes and rerun commands']];

  exports.run = function() {
    var args, command, type;
    args = process.argv.slice(2);
    type = args.shift().split(':');
    command = type[1];
    if (command != null) {
      return otherCommand(type[0], command, args);
    } else {
      parseOptions(process.argv.slice(2));
      if (options.help) {
        return usage();
      }
      if (options.version) {
        return version();
      }
      if (options.output) {
        outputDir = options.output;
      }
      return mainCommand();
    }
  };

  timeStart = timeEnd = null;

  _startTimer = function() {
    return timeStart = new Date();
  };

  _endTimer = function() {
    timeEnd = new Date();
    return Cordjs.utils.timeLog("Timer: " + (timeEnd - timeStart) + " milliseconds");
  };

  mainCommand = function() {
    var completeSync, initCompileWidgets, updateCoffeeTimestamp;
    if (!testCommandDir()) {
      return false;
    }
    if (options.clean) {
      removeDirSync(outputDir);
    }
    _startTimer();
    createDir(outputDir, function(existDir) {
      if (!existDir) {
        Cordjs.utils.timeLog("Output directory created '" + outputDir + "'");
      }
      counters.syncFiles = counters.copiesFiles = 0;
      return syncFiles(publicDir, path.normalize(publicDir), function() {
        return Cordjs.sendCommand("coffee -bco " + (path.join(outputDir, publicDir)) + " " + publicDir, function(error) {
          if (error) {
            return Cordjs.utils.timeLogError('Coffescript compiler');
          } else {
            updateCoffeeTimestamp(sources);
            exec("sass --update " + publicDir + ":" + (path.join(outputDir, publicDir)), function(error) {
              if (error) {
                return Cordjs.utils.timeLogError('Sass compiler');
              }
            });
            if (options.build) {
              return syncFiles('node_modules', path.normalize('node_modules'), completeSync);
            }
            return completeSync();
          }
        });
      });
    });
    updateCoffeeTimestamp = function(sources) {
      var source, _i, _len, _results,
        _this = this;
      _results = [];
      for (_i = 0, _len = sources.length; _i < _len; _i++) {
        source = sources[_i];
        _results.push((function(source) {
          var extname, outputSource;
          extname = path.extname(source);
          if (extname === '.coffee') {
            outputSource = outputPath(source, path.normalize(publicDir));
            return fs.stat(source, function(err, stat) {
              try {
                return fs.utimesSync(outputSource, stat.atime, stat.mtime);
              } catch (_error) {}
            });
          }
        })(source));
      }
      return _results;
    };
    completeSync = function() {
      return Cordjs.sendCommand("coffee -bc -o " + outputDir + " server.coffee", function(error) {
        if (error) {
          return Cordjs.utils.timeLogError('Coffescript compiler');
        } else {
          counters.syncFiles++;
          counters.copiesFiles++;
          return initCompileWidgets(function() {
            Cordjs.utils.timeLog("Sync files is complete! Total " + counters.syncFiles + " files, " + counters.copiesFiles + " files copied");
            _endTimer();
            if (options.server) {
              pathToNodeInit = "" + (path.join(baseDirFull, outputDir, publicDir, pathToNodeInit));
              return startServer();
            }
          });
        }
      });
    };
    return initCompileWidgets = function(callback) {
      var basePath, baseUrl, configPaths;
      configPaths = require("" + (path.join(baseDirFull, outputDir, publicDir, pathToCore)) + "configPaths");
      baseUrl = path.join(outputDir, publicDir);
      requirejs.config({
        baseUrl: baseUrl,
        nodeRequire: require
      });
      requirejs.config(configPaths);
      basePath = path.normalize(publicDir);
      return requirejs(["cord!config"], function(config) {
        var dirname, extname, outputSource, source, widgetsPaths, _i, _len;
        config.PUBLIC_PREFIX = baseUrl;
        widgetsWaitComliler = [];
        widgetsPaths = {};
        for (_i = 0, _len = sources.length; _i < _len; _i++) {
          source = sources[_i];
          extname = path.extname(source);
          if (extname === '.coffee' && parseInt(source.indexOf('/widgets/')) > 0) {
            dirname = getWidgetPath(source);
            if (!widgetsPaths[dirname]) {
              widgetsPaths[dirname] = dirname;
              outputSource = outputPath(source, basePath);
              widgetsWaitComliler.push(dirname);
            }
          }
        }
        return compileWidget(callback);
      });
    };
  };

  testCommandDir = function() {
    try {
      baseDirFull = path.dirname(fs.realpathSync(publicDir));
      return true;
    } catch (e) {
      if (e.code === 'ENOENT') {
        Cordjs.utils.timeLog("Error: no such public directory '" + publicDir + "'");
      }
      return false;
    }
  };

  createDir = function(dir, callback) {
    var dirFull;
    try {
      dirFull = path.dirname(fs.realpathSync(dir));
      return typeof callback === "function" ? callback(dirFull) : void 0;
    } catch (e) {
      if (e.code === 'ENOENT') {
        return Cordjs.sendCommand("mkdir -p " + dir, function(error) {
          if (error) {
            util.print(error);
          }
          return typeof callback === "function" ? callback() : void 0;
        });
      }
    }
  };

  getWidgetPath = function(source) {
    var pathToWidget, widgetClassName;
    source = path.dirname(source);
    source = source.replace('public/bundles', '');
    source = source.replace('/widgets/', '//');
    widgetClassName = path.basename(source);
    widgetClassName = widgetClassName.charAt(0).toUpperCase() + widgetClassName.slice(1);
    pathToWidget = source.split('/');
    pathToWidget.pop();
    return "" + (pathToWidget.join('/')) + "/" + widgetClassName;
  };

  compileWidget = function(callback) {
    var widgetName,
      _this = this;
    widgetName = widgetsWaitComliler.pop();
    if (!(widgetName != null)) {
      return typeof callback === "function" ? callback() : void 0;
    }
    return requirejs(["cord-w!" + widgetName, "cord!widgetCompiler", "cord!config"], function(WidgetClass, widgetCompiler, config) {
      var widget;
      widget = new WidgetClass(true);
      widgetCompiler.reset(widget);
      return widget.compileTemplate(function(err, output) {
        var tmplFullPath;
        if (err) {
          throw err;
        }
        tmplFullPath = "./" + config.PUBLIC_PREFIX + "/bundles/" + (widget.getTemplatePath()) + ".structure.json";
        return fs.writeFile(tmplFullPath, widgetCompiler.getStructureCode(false), function(err) {
          return compileWidget(callback);
        });
      });
    });
  };

  otherCommand = function(type, command, args) {
    if (Cordjs.Generator.exists(type)) {
      return Cordjs.Generator["do"](type, command, args);
    } else {
      return console.log("Generator " + type + " not found. Available generators: " + (Cordjs.Generator.list()));
    }
  };

  create = function(type) {
    type = type.shift();
    if (!(type != null)) {
      return console.log('What create: app or bundle?');
    } else if (!Cordjs.creator.exist(type)) {
      return console.log("Generator " + type + " not found");
    }
  };

  startServer = function() {
    serverChild = spawn("node", [path.join(outputDir, 'server.js'), path.join(outputDir, publicDir)]);
    serverChild.stdout.on('data', function(data) {
      return util.print(data);
    });
    return serverChild.stderr.on('data', function(error) {
      return util.print(error);
    });
  };

  stopServer = function() {
    return serverChild != null ? serverChild.kill() : void 0;
  };

  restartServer = function() {
    stopServer();
    startServer();
    return Cordjs.utils.timeLog('Server restarted');
  };

  syncFiles = function(source, base, callback) {
    return fs.stat(source, function(err, stats) {
      var walker;
      if (stats.isFile()) {
        return syncFile(source, base);
      }
      walker = walk.walk(source, {
        followLinks: false
      });
      walker.on('directory', function(root, stat, next) {
        source = path.join(root, stat.name);
        if (hidden(source)) {
          return next();
        }
        if (options.watch) {
          watchDir(source, base);
        }
        return next();
      });
      walker.on('file', function(root, stat, next) {
        source = path.join(root, stat.name);
        if (hidden(source)) {
          return next();
        }
        syncFile(source, base, function() {
          counters.syncFiles++;
          return next();
        });
        return next();
      });
      walker.on('symbolicLink', function(root, stat, next) {
        var dirname, symbolicLink;
        symbolicLink = path.join(root, stat.name);
        dirname = path.dirname(symbolicLink);
        source = path.join(dirname, fs.readlinkSync(symbolicLink));
        if (hidden(symbolicLink)) {
          return next();
        }
        syncFile(source, base, function() {
          counters.syncFiles++;
          return next();
        }, false, symbolicLink);
        return next();
      });
      return walker.on('end', function() {
        return typeof callback === "function" ? callback() : void 0;
      });
    });
  };

  syncFile = function(source, base, callback, onlyWatch, symbolicLink) {
    var baseSource, completeSync, extname;
    if (onlyWatch == null) {
      onlyWatch = false;
    }
    baseSource = (symbolicLink ? symbolicLink : source);
    if (!onlyWatch) {
      sources.push(baseSource);
    }
    if (!onlyWatch && options.watch) {
      watchFile(baseSource, base, symbolicLink);
    }
    extname = path.extname(baseSource);
    if (onlyWatch && parseInt(source.indexOf('/widgets/')) > 0) {
      widgetsWaitComliler.push(getWidgetPath(source));
    }
    completeSync = function() {
      return compileWidget(callback);
    };
    switch (extname) {
      case ".coffee":
      case ".scss":
      case ".sass":
        if (!onlyWatch) {
          counters.copiesFiles++;
        }
        if (extname === ".coffee" && onlyWatch) {
          return Cordjs.sendCommand("coffee -bco " + (path.dirname(outputPath(baseSource, base))) + " " + source, function(error) {
            if (error) {
              Cordjs.utils.timeLogError("Coffescript compiler '" + baseSource + "'");
            } else {
              Cordjs.utils.timeLog("Update CoffeeScript '" + baseSource + "'");
            }
            return completeSync();
          });
        } else if (extname === (".scss" || ".sass") && onlyWatch) {
          return exec("sass --update " + (path.dirname(outputPath(baseSource, base))) + ":" + source, function(error) {
            if (error) {
              Cordjs.utils.timeLogError('Sass compiler');
            } else {
              Cordjs.utils.timeLog("Update Saas '" + baseSource + "'");
            }
            return completeSync();
          });
        } else {
          return completeSync();
        }
        break;
      default:
        if (onlyWatch) {
          return Cordjs.utils.timeLog("Update file '" + baseSource + "'");
        } else {
          if (options.dev || options.build) {
            return copyFile(source, base, function(err) {
              return completeSync();
            }, symbolicLink);
          } else {
            counters.syncFiles--;
            return completeSync();
          }
        }
    }
  };

  copyFile = function(source, base, callback, symbolicLink) {
    var copyHelper, fileDir, filePath;
    filePath = outputPath((symbolicLink ? symbolicLink : source), base);
    fileDir = path.dirname(filePath);
    copyHelper = function() {
      return fs.stat(source, function(err, stat) {
        if (err) {
          if (typeof callback === "function") {
            callback(err);
          }
        }
        if (!isDiffSource(source, filePath)) {
          return typeof callback === "function" ? callback() : void 0;
        }
        return util.pump(fs.createReadStream(source), fs.createWriteStream(filePath), function(err) {
          if (err) {
            if (typeof callback === "function") {
              callback(err);
            }
          }
          counters.copiesFiles++;
          return fs.utimes(filePath, stat.atime, stat.mtime, callback);
        });
      });
    };
    return exists(fileDir, function(itExists) {
      if (itExists) {
        return copyHelper();
      } else {
        return exec("mkdir -p " + fileDir, copyHelper);
      }
    });
  };

  isDiffSource = function(baseSource, outputSource, baseStat, outputStat) {
    if (!(baseStat != null)) {
      baseStat = fs.statSync(baseSource);
    }
    try {
      if (!(outputStat != null)) {
        outputStat = fs.statSync(outputSource);
      }
      if (path.extname(baseSource) === '.coffee') {
        if (baseStat.mtime.getTime() === outputStat.mtime.getTime()) {
          return false;
        }
      } else {
        if (outputStat.size === baseStat.size && baseStat.mtime.getTime() === outputStat.mtime.getTime()) {
          return false;
        }
      }
    } catch (_error) {}
    return true;
  };

  watchFile = function(source, base, symbolicLink) {
    var prevStats, rewatch, sync, syncTimeout, watchErr, watcher;
    prevStats = null;
    syncTimeout = null;
    watchErr = function(e) {
      if (e.code === 'ENOENT') {
        if (sources.indexOf(source) === -1) {
          return;
        }
        try {
          rewatch();
          return sync();
        } catch (e) {
          removeSource(source, base, true);
          return Cordjs.utils.timeLog("Remove file '" + source + "'");
        }
      } else {
        if (e.code === 'EMFILE') {
          Cordjs.utils.timeLogError("Max limit opened files. Try change limit. " + 'For mac use: ulimit -n 65536'.yellow);
        }
        throw e;
      }
    };
    sync = function() {
      clearTimeout(syncTimeout);
      return syncTimeout = wait(25, function() {
        return fs.stat(source, function(err, stats) {
          if (err) {
            return watchErr(err);
          }
          if (prevStats && stats.size === prevStats.size && stats.mtime.getTime() === prevStats.mtime.getTime()) {
            return rewatch();
          }
          prevStats = stats;
          return syncFile(source, base, function() {
            if (options.server) {
              restartServer();
            }
            return rewatch();
          }, true, symbolicLink);
        });
      });
    };
    try {
      watcher = fs.watch(source, sync);
    } catch (e) {
      watchErr(e);
    }
    return rewatch = function() {
      if (watcher != null) {
        watcher.close();
      }
      return watcher = fs.watch(source, sync);
    };
  };

  watchDir = function(source, base) {
    var readdirTimeout, watcher;
    readdirTimeout = null;
    try {
      return watcher = fs.watch(source, function() {
        clearTimeout(readdirTimeout);
        return readdirTimeout = wait(25, function() {
          return fs.readdir(source, function(err, files) {
            var file, _i, _len, _results;
            if (err) {
              if (err.code !== 'ENOENT') {
                throw err;
              }
              watcher.close();
              return unwatchDir(source, base);
            }
            _results = [];
            for (_i = 0, _len = files.length; _i < _len; _i++) {
              file = files[_i];
              file = path.join(source, file);
              if (sources.some(function(s) {
                return s.indexOf(file) >= 0;
              })) {
                continue;
              }
              if (hidden(file)) {
                continue;
              }
              Cordjs.utils.timeLog("Add file '" + file + "'");
              sources.push(file);
              _results.push(syncFiles(file, base));
            }
            return _results;
          });
        });
      });
    } catch (e) {
      if (e.code !== 'ENOENT') {
        throw e;
      }
    }
  };

  unwatchDir = function(source, base) {
    var file, prevSources, toRemove, _i, _len;
    prevSources = sources.slice(0);
    toRemove = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = sources.length; _i < _len; _i++) {
        file = sources[_i];
        if (file.indexOf(source) >= 0) {
          _results.push(file);
        }
      }
      return _results;
    })();
    for (_i = 0, _len = toRemove.length; _i < _len; _i++) {
      file = toRemove[_i];
      removeSource(file, base, true);
    }
    if (!sources.some(function(s, i) {
      return prevSources[i] !== s;
    })) {

    }
  };

  removeSource = function(source, base, remove) {
    var index, outPath;
    index = sources.indexOf(source);
    sources.splice(index, 1);
    if (remove) {
      outPath = outputPath(source, base);
      return exists(outPath, function(itExists) {
        if (itExists) {
          return fs.unlink(outPath, function(err) {
            if (err && err.code !== 'ENOENT') {
              throw err;
            }
            return Cordjs.utils.timeLog("removed " + source);
          });
        }
      });
    }
  };

  removeDirSync = function(source) {
    var file, filename, stat, _i, _len, _ref1;
    try {
      _ref1 = fs.readdirSync(source);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        file = _ref1[_i];
        filename = path.join(source, file);
        stat = fs.statSync(filename);
        if (filename === "." || filename === "..") {
          continue;
        }
        if (stat.isDirectory()) {
          removeDirSync(filename);
        } else {
          fs.unlinkSync(filename);
        }
      }
      return fs.rmdirSync(source);
    } catch (e) {
      if (e.code !== 'ENOENT') {
        throw e;
      }
    }
  };

  outputPath = function(source, base) {
    var baseDir, dir, filename, srcDir;
    filename = path.basename(source);
    if (path.extname(source) === '.coffee') {
      filename = path.basename(source, path.extname(source)) + '.js';
    }
    srcDir = path.dirname(source);
    baseDir = srcDir;
    dir = path.join(outputDir, baseDir);
    return path.join(dir, filename);
  };

  parseOptions = function(args) {
    var o, optionParser;
    optionParser = new optparse.OptionParser(OptionsList, EmptyArguments);
    o = options = optionParser.parse(args);
    if (options.autorestart) {
      options.server = options.watch = true;
    }
    if (o["arguments"].length) {
      return publicDir = o["arguments"][0];
    }
  };

  usage = function() {
    return printLine((new optparse.OptionParser(OptionsList, EmptyArguments)).help());
  };

  version = function() {
    return printLine("Cordjs current version: " + Cordjs.VERSION.green);
  };

  wait = function(milliseconds, func) {
    return setTimeout(func, milliseconds);
  };

  exists = fs.exists || path.exists;

  hidden = function(file) {
    return /\/\.|~$/.test(file) || /^\.|~$/.test(file);
  };

  printLine = function(line) {
    return process.stdout.write(line + '\n');
  };

  printWarn = function(line) {
    return process.stderr.write(line + '\n');
  };

}).call(this);
