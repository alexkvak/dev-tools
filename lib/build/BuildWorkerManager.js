// Generated by CoffeeScript 1.6.3
var BuildWorkerManager, Future, fork;

fork = require('child_process').fork;

Future = require('../utils/Future');

BuildWorkerManager = (function() {
  /*
  Build worker process representation on the main build process side.
  */

  BuildWorkerManager.MAX_SENDING_TASKS = 30000;

  BuildWorkerManager.IDLE_STOP_TIMEOUT = 3000;

  BuildWorkerManager._idCounter = 0;

  BuildWorkerManager.prototype.id = 0;

  BuildWorkerManager.prototype._process = null;

  BuildWorkerManager.prototype._tasks = null;

  BuildWorkerManager.prototype._sendingTask = 0;

  BuildWorkerManager.prototype._acceptReady = null;

  BuildWorkerManager.prototype._workload = 0;

  BuildWorkerManager.prototype._taskCounter = 0;

  BuildWorkerManager.prototype.totalTasksCount = 0;

  BuildWorkerManager.prototype._killTimeout = null;

  BuildWorkerManager.prototype._stopped = false;

  function BuildWorkerManager(manager) {
    var _this = this;
    this.manager = manager;
    this.id = ++BuildWorkerManager._idCounter;
    this._process = fork(__dirname + '/build-worker.js');
    this._acceptReady = Future.resolved(this);
    this._tasks = {};
    this._process.on('message', function(m) {
      switch (m.type) {
        case 'completed':
          _this._tasks[m.task].resolve();
          delete _this._tasks[m.task];
          _this._taskCounter--;
          if (_this._taskCounter === 0 && !_this._stopped) {
            return _this._killTimeout = setTimeout(function() {
              if (_this._taskCounter === 0) {
                return _this.stop();
              }
            }, BuildWorkerManager.IDLE_STOP_TIMEOUT);
          }
      }
    });
  }

  BuildWorkerManager.prototype.addTask = function(taskParams) {
    /*
    @return Future[Nothing]
    */

    var taskWorkload,
      _this = this;
    if (this.canAcceptTask()) {
      this._tasks[taskParams.id] = Future.single();
      this._process.send(taskParams);
      this._sendingTask++;
      if (!this.canAcceptTask()) {
        this._acceptReady = Future.single();
      }
      this._taskCounter++;
      this.totalTasksCount++;
      if (this._killTimeout) {
        clearTimeout(this._killTimeout);
      }
      taskWorkload = this.getTaskWorkload(taskParams);
      this._workload += taskWorkload;
      return this._tasks[taskParams.id].done(function() {
        return _this._workload -= taskWorkload;
      });
    } else {
      throw new Error("Can't accept task now!");
    }
  };

  BuildWorkerManager.prototype.getTaskWorkload = function(taskParams) {
    switch (taskParams.info.ext) {
      case '.coffee':
        return 1;
      case '.styl':
        return 1.1;
      case '.js':
        return 0.2;
      default:
        return 0;
    }
  };

  BuildWorkerManager.prototype.stop = function() {
    /*
    Kills worker process and stops this worker.
    */

    if (this._killTimeout) {
      clearTimeout(this._killTimeout);
    }
    if (!this._stopped) {
      this._process.kill();
      this.manager.stopWorker(this);
      return this._stopped = true;
    }
  };

  BuildWorkerManager.prototype.canAcceptTask = function() {
    return this._sendingTask < BuildWorkerManager.MAX_SENDING_TASKS;
  };

  BuildWorkerManager.prototype.acceptReady = function() {
    return this._acceptReady;
  };

  BuildWorkerManager.prototype.getWorkload = function() {
    return this._workload;
  };

  return BuildWorkerManager;

})();

module.exports = BuildWorkerManager;
