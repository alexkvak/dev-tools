// Generated by CoffeeScript 1.3.3
var EmptyArguments, OptionsList, copyFile, countFiles, exec, exists, fs, hidden, options, optparse, outputDir, outputPath, parseOptions, path, pathToNodeInit, printLine, printWarn, publicDir, removeDirSync, removeSource, restartServer, server, sources, spawn, syncFile, syncFiles, timeLog, timerRestartServer, unwatchDir, usage, util, wait, walk, watchDir, watchFile, _ref;

fs = require('fs');

util = require('util');

path = require('path');

walk = require('walk');

optparse = require('./optparse');

_ref = require('child_process'), spawn = _ref.spawn, exec = _ref.exec;

publicDir = 'public';

outputDir = 'target';

options = {};

sources = [];

countFiles = null;

server = null;

timerRestartServer = null;

pathToNodeInit = "/bundles/cord/core/nodeInit";

EmptyArguments = 'Usage: cordjs [options] path/to/project -- [args]';

OptionsList = [['-a', '--autorestart', 'autorestart server'], ['-d', '--dev', 'development mode - copy all files to the outputDir'], ['-h', '--help', 'display this help message'], ['-o', '--output [DIR]', 'output directory'], ['-s', '--server', 'start server'], ['-w', '--watch', 'watch scripts for changes and rerun commands']];

exports.run = function() {
  var outputDirFull, publicDirFull;
  parseOptions();
  if (options.help) {
    return usage();
  }
  if (options.output) {
    outputDir = options.output;
  }
  try {
    publicDirFull = fs.realpathSync(publicDir);
  } catch (e) {
    if (e.code === 'ENOENT') {
      timeLog("Error: no such public directory '" + publicDir + "'");
      return false;
    }
  }
  outputDirFull = path.join(path.dirname(publicDirFull), outputDir);
  removeDirSync(outputDirFull);
  return exec("mkdir -p " + outputDirFull, function() {
    timeLog("Output directory created '" + outputDirFull + "'");
    countFiles = 0;
    return syncFiles(publicDirFull, path.normalize(publicDirFull), function() {
      return exec("coffee -bc -o " + outputDirFull + " " + publicDirFull, function() {
        exec("sass --update " + publicDirFull + ":" + outputDirFull);
        timeLog("Synchronized " + countFiles + " files");
        if (options.server) {
          pathToNodeInit = "" + outputDirFull + pathToNodeInit;
          return server = require(pathToNodeInit);
        }
      });
    });
  });
};

syncFiles = function(source, base, callback) {
  return fs.stat(source, function(err, stats) {
    var walker;
    if (stats.isFile()) {
      return syncFile(source, base);
    }
    walker = walk.walk(source);
    walker.on('directory', function(root, stat, next) {
      source = path.join(root, stat.name);
      if (hidden(source)) {
        return next();
      }
      if (options.watch) {
        watchDir(source, base);
      }
      return next();
    });
    walker.on('file', function(root, stat, next) {
      source = path.join(root, stat.name);
      if (hidden(source)) {
        return next();
      }
      return syncFile(source, base, function() {
        countFiles++;
        return next();
      });
    });
    return walker.on('end', function() {
      return typeof callback === "function" ? callback() : void 0;
    });
  });
};

syncFile = function(source, base, callback, onlyWatch) {
  var extname;
  if (onlyWatch == null) {
    onlyWatch = false;
  }
  if (!onlyWatch) {
    sources.push(source);
  }
  if (!onlyWatch && options.watch) {
    watchFile(source, base);
  }
  if (onlyWatch) {
    restartServer();
  }
  extname = path.extname(source);
  switch (extname) {
    case ".coffee":
    case ".scss":
    case ".sass":
      if (extname === ".coffee" && onlyWatch) {
        return exec("coffee -bc -o " + (path.dirname(outputPath(source, base))) + " " + source, function() {
          timeLog("Compile CoffeeScript " + source);
          return typeof callback === "function" ? callback() : void 0;
        });
      } else if (extname === (".scss" || ".sass") && onlyWatch) {
        return exec("sass --update " + (path.dirname(outputPath(source, base))) + ":" + source, function() {
          timeLog("Compile Saas " + source);
          return typeof callback === "function" ? callback() : void 0;
        });
      } else {
        return typeof callback === "function" ? callback() : void 0;
      }
      break;
    default:
      if (options.dev) {
        if (onlyWatch) {
          timeLog("update file " + source);
        }
        return copyFile(source, base, function(err) {
          return typeof callback === "function" ? callback() : void 0;
        });
      } else {
        countFiles--;
        return typeof callback === "function" ? callback() : void 0;
      }
  }
};

restartServer = function() {
  if (!options.autorestart) {
    return;
  }
  clearTimeout(timerRestartServer);
  return timerRestartServer = wait(200, function() {
    if (typeof server.stop === "function") {
      server.stop();
    }
    return server = require("" + source + "/bundles/cord/core/nodeInit");
  });
};

copyFile = function(source, base, callback) {
  var copyHelper, fileDir, filePath;
  filePath = outputPath(source, base);
  fileDir = path.dirname(filePath);
  copyHelper = function() {
    return fs.stat(source, function(err, stat) {
      if (err) {
        if (typeof callback === "function") {
          callback(err);
        }
      }
      return util.pump(fs.createReadStream(source), fs.createWriteStream(filePath), function(err) {
        if (err) {
          if (typeof callback === "function") {
            callback(err);
          }
        }
        return fs.utimes(filePath, stat.atime, stat.mtime, callback);
      });
    });
  };
  return exists(fileDir, function(itExists) {
    if (itExists) {
      return copyHelper();
    } else {
      return exec("mkdir -p " + fileDir, copyHelper);
    }
  });
};

watchFile = function(source, base) {
  var prevStats, rewatch, sync, syncTimeout, watchErr, watcher;
  prevStats = null;
  syncTimeout = null;
  watchErr = function(e) {
    if (e.code === 'ENOENT') {
      if (sources.indexOf(source) === -1) {
        return;
      }
      try {
        rewatch();
        return sync();
      } catch (e) {
        return removeSource(source, base, true);
      }
    } else {
      throw e;
    }
  };
  sync = function() {
    clearTimeout(syncTimeout);
    return syncTimeout = wait(25, function() {
      return fs.stat(source, function(err, stats) {
        if (err) {
          return watchErr(err);
        }
        if (prevStats && stats.size === prevStats.size && stats.mtime.getTime() === prevStats.mtime.getTime()) {
          return rewatch();
        }
        prevStats = stats;
        return syncFile(source, base, function() {
          return rewatch();
        }, true);
      });
    });
  };
  try {
    watcher = fs.watch(source, sync);
  } catch (e) {
    watchErr(e);
  }
  return rewatch = function() {
    if (watcher != null) {
      watcher.close();
    }
    return watcher = fs.watch(source, sync);
  };
};

watchDir = function(source, base) {
  var readdirTimeout, watcher;
  readdirTimeout = null;
  try {
    return watcher = fs.watch(source, function() {
      clearTimeout(readdirTimeout);
      return readdirTimeout = wait(25, function() {
        return fs.readdir(source, function(err, files) {
          var file, _i, _len, _results;
          if (err) {
            if (err.code !== 'ENOENT') {
              throw err;
            }
            watcher.close();
            return unwatchDir(source, base);
          }
          _results = [];
          for (_i = 0, _len = files.length; _i < _len; _i++) {
            file = files[_i];
            file = path.join(source, file);
            if (sources.some(function(s) {
              return s.indexOf(file) >= 0;
            })) {
              continue;
            }
            sources.push(file);
            _results.push(syncFiles(file, base));
          }
          return _results;
        });
      });
    });
  } catch (e) {
    if (e.code !== 'ENOENT') {
      throw e;
    }
  }
};

unwatchDir = function(source, base) {
  var file, prevSources, toRemove, _i, _len;
  prevSources = sources.slice(0);
  toRemove = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = sources.length; _i < _len; _i++) {
      file = sources[_i];
      if (file.indexOf(source) >= 0) {
        _results.push(file);
      }
    }
    return _results;
  })();
  for (_i = 0, _len = toRemove.length; _i < _len; _i++) {
    file = toRemove[_i];
    removeSource(file, base, true);
  }
  if (!sources.some(function(s, i) {
    return prevSources[i] !== s;
  })) {

  }
};

removeSource = function(source, base, remove) {
  var index, outPath;
  index = sources.indexOf(source);
  sources.splice(index, 1);
  if (remove) {
    outPath = outputPath(source, base);
    return exists(outPath, function(itExists) {
      if (itExists) {
        return fs.unlink(outPath, function(err) {
          if (err && err.code !== 'ENOENT') {
            throw err;
          }
          return timeLog("removed " + source);
        });
      }
    });
  }
};

removeDirSync = function(source) {
  var file, filename, stat, _i, _len, _ref1;
  try {
    _ref1 = fs.readdirSync(source);
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      file = _ref1[_i];
      filename = path.join(source, file);
      stat = fs.statSync(filename);
      if (filename === "." || filename === "..") {
        continue;
      }
      if (stat.isDirectory()) {
        removeDirSync(filename);
      } else {
        fs.unlinkSync(filename);
      }
    }
    return fs.rmdirSync(source);
  } catch (e) {
    if (e.code !== 'ENOENT') {
      throw e;
    }
  }
};

outputPath = function(source, base) {
  var baseDir, dir, filename, srcDir;
  filename = path.basename(source);
  srcDir = path.dirname(source);
  baseDir = base === '.' ? srcDir : srcDir.substring(base.length);
  dir = path.join(outputDir, baseDir);
  return path.join(dir, filename);
};

parseOptions = function() {
  var o, optionParser;
  optionParser = new optparse.OptionParser(OptionsList, EmptyArguments);
  o = options = optionParser.parse(process.argv.slice(2));
  if (options.autorestart) {
    options.server = options.watch = true;
  }
  if (o["arguments"].length) {
    publicDir = o["arguments"][0];
  }
};

usage = function() {
  return printLine((new optparse.OptionParser(OptionsList, EmptyArguments)).help());
};

wait = function(milliseconds, func) {
  return setTimeout(func, milliseconds);
};

exists = fs.exists || path.exists;

hidden = function(file) {
  return /\/\.|~$/.test(file) || /^\.|~$/.test(file);
};

timeLog = function(message) {
  return console.log("" + ((new Date).toLocaleTimeString()) + " - " + message);
};

printLine = function(line) {
  return process.stdout.write(line + '\n');
};

printWarn = function(line) {
  return process.stderr.write(line + '\n');
};
