// Generated by CoffeeScript 1.3.3
var Cordjs, EmptyArguments, OptionsList, baseDirFull, copyFile, countFiles, create, exec, exists, fs, hidden, mainCommand, options, optparse, otherCommand, outputDir, outputPath, parseOptions, path, pathToNodeInit, printLine, printWarn, publicDir, removeDirSync, removeSource, restartServer, serverChild, sources, spawn, startServer, stopServer, syncFile, syncFiles, unwatchDir, usage, util, version, wait, walk, watchDir, watchFile, _ref;

fs = require('fs');

util = require('util');

path = require('path');

walk = require('walk');

optparse = require('./optparse');

_ref = require('child_process'), spawn = _ref.spawn, exec = _ref.exec;

Cordjs = require('./cordjs');

util = require('util');

publicDir = 'public';

outputDir = 'target';

options = {};

sources = [];

countFiles = null;

pathToNodeInit = "/bundles/cord/core/nodeInit";

baseDirFull = null;

serverChild = null;

EmptyArguments = 'Usage: cordjs [options] path/to/project -- [args]';

OptionsList = [['-a', '--autorestart', 'autorestart server'], ['-b', '--build', 'build project'], ['-d', '--dev', 'development mode - copy all files to the outputDir'], ['-h', '--help', 'display this help message'], ['-o', '--output [DIR]', 'output directory'], ['-s', '--server', 'start server'], ['-v', '--version', 'display the version number'], ['-w', '--watch', 'watch scripts for changes and rerun commands']];

exports.run = function() {
  var args, command, type;
  args = process.argv.slice(2);
  type = args.shift().split(':');
  command = type[1];
  if (command != null) {
    return otherCommand(type[0], command, args);
  } else {
    parseOptions(process.argv.slice(2));
    if (options.help) {
      return usage();
    }
    if (options.version) {
      return version();
    }
    if (options.output) {
      outputDir = options.output;
    }
    return mainCommand();
  }
};

mainCommand = function() {
  var completeSync;
  try {
    baseDirFull = path.dirname(fs.realpathSync(publicDir));
  } catch (e) {
    if (e.code === 'ENOENT') {
      Cordjs.utils.timeLog("Error: no such public directory '" + publicDir + "'");
      return false;
    }
  }
  removeDirSync(outputDir);
  exec("mkdir -p " + outputDir, function() {
    Cordjs.utils.timeLog("Output directory created '" + outputDir + "'");
    countFiles = 0;
    return syncFiles(publicDir, path.normalize(publicDir), function() {
      return exec("coffee -bco " + (path.join(outputDir, publicDir)) + " " + publicDir, function(e) {
        exec("sass --update " + publicDir + ":" + (path.join(outputDir, publicDir)));
        if (options.build) {
          return syncFiles('node_modules', path.normalize('node_modules'), completeSync);
        }
        return completeSync();
      });
    });
  });
  return completeSync = function() {
    return exec("coffee -bc -o " + outputDir + " server.coffee", function() {
      countFiles++;
      Cordjs.utils.timeLog("Synchronized " + countFiles + " files");
      if (options.server) {
        pathToNodeInit = "" + (path.join(baseDirFull, outputDir, publicDir, pathToNodeInit));
        return startServer();
      }
    });
  };
};

otherCommand = function(type, command, args) {
  if (Cordjs.Generator.exists(type)) {
    return Cordjs.Generator["do"](type, command, args);
  } else {
    return console.log("Generator " + type + " not found. Available generators: " + (Cordjs.Generator.list()));
  }
};

create = function(type) {
  type = type.shift();
  if (!(type != null)) {
    console.log('What create: app or bundle?');
  } else if (!Cordjs.creator.exist(type)) {
    console.log("Generator " + type + " not found");
  }
  return console.log('type: ', type);
};

startServer = function() {
  serverChild = spawn("node", [path.join(outputDir, 'server.js'), path.join(outputDir, publicDir)]);
  serverChild.stdout.on('data', function(data) {
    return util.print(data);
  });
  return serverChild.stderr.on('data', function(error) {
    return util.print(error);
  });
};

stopServer = function() {
  return serverChild != null ? serverChild.kill() : void 0;
};

restartServer = function() {
  stopServer();
  startServer();
  return Cordjs.utils.timeLog('Server restarted');
};

syncFiles = function(source, base, callback) {
  return fs.stat(source, function(err, stats) {
    var walker;
    if (stats.isFile()) {
      return syncFile(source, base);
    }
    walker = walk.walk(source, {
      followLinks: false
    });
    walker.on('directory', function(root, stat, next) {
      source = path.join(root, stat.name);
      if (hidden(source)) {
        return next();
      }
      if (options.watch) {
        watchDir(source, base);
      }
      return next();
    });
    walker.on('file', function(root, stat, next) {
      source = path.join(root, stat.name);
      if (hidden(source)) {
        return next();
      }
      syncFile(source, base, function() {
        countFiles++;
        return next();
      });
      return next();
    });
    walker.on('symbolicLink', function(root, stat, next) {
      var dirname, symbolicLink;
      symbolicLink = path.join(root, stat.name);
      dirname = path.dirname(symbolicLink);
      source = path.join(dirname, fs.readlinkSync(symbolicLink));
      if (hidden(symbolicLink)) {
        return next();
      }
      syncFile(source, base, function() {
        countFiles++;
        return next();
      }, false, symbolicLink);
      return next();
    });
    return walker.on('end', function() {
      return typeof callback === "function" ? callback() : void 0;
    });
  });
};

syncFile = function(source, base, callback, onlyWatch, symbolicLink) {
  var baseSource, extname;
  if (onlyWatch == null) {
    onlyWatch = false;
  }
  baseSource = (symbolicLink ? symbolicLink : source);
  if (!onlyWatch) {
    sources.push(baseSource);
  }
  if (!onlyWatch && options.watch) {
    watchFile(baseSource, base, symbolicLink);
  }
  extname = path.extname(baseSource);
  switch (extname) {
    case ".coffee":
    case ".scss":
    case ".sass":
      if (extname === ".coffee" && onlyWatch) {
        return exec("coffee -bc -o " + (path.dirname(outputPath(baseSource, base))) + " " + source, function() {
          Cordjs.utils.timeLog("Update CoffeeScript '" + baseSource + "'");
          return typeof callback === "function" ? callback() : void 0;
        });
      } else if (extname === (".scss" || ".sass") && onlyWatch) {
        return exec("sass --update " + (path.dirname(outputPath(baseSource, base))) + ":" + source, function() {
          Cordjs.utils.timeLog("Update Saas '" + baseSource + "'");
          return typeof callback === "function" ? callback() : void 0;
        });
      } else {
        return typeof callback === "function" ? callback() : void 0;
      }
      break;
    default:
      if (onlyWatch) {
        Cordjs.utils.timeLog("Update file '" + baseSource + "'");
      }
      if (options.dev || options.build) {
        return copyFile(source, base, function(err) {
          return typeof callback === "function" ? callback() : void 0;
        }, symbolicLink);
      } else {
        countFiles--;
        return typeof callback === "function" ? callback() : void 0;
      }
  }
};

copyFile = function(source, base, callback, symbolicLink) {
  var copyHelper, fileDir, filePath;
  filePath = outputPath((symbolicLink ? symbolicLink : source), base);
  fileDir = path.dirname(filePath);
  copyHelper = function() {
    return fs.stat(source, function(err, stat) {
      if (err) {
        if (typeof callback === "function") {
          callback(err);
        }
      }
      return util.pump(fs.createReadStream(source), fs.createWriteStream(filePath), function(err) {
        if (err) {
          if (typeof callback === "function") {
            callback(err);
          }
        }
        return fs.utimes(filePath, stat.atime, stat.mtime, callback);
      });
    });
  };
  return exists(fileDir, function(itExists) {
    if (itExists) {
      return copyHelper();
    } else {
      return exec("mkdir -p " + fileDir, copyHelper);
    }
  });
};

watchFile = function(source, base, symbolicLink) {
  var prevStats, rewatch, sync, syncTimeout, watchErr, watcher;
  prevStats = null;
  syncTimeout = null;
  watchErr = function(e) {
    if (e.code === 'ENOENT') {
      if (sources.indexOf(source) === -1) {
        return;
      }
      try {
        rewatch();
        return sync();
      } catch (e) {
        removeSource(source, base, true);
        return Cordjs.utils.timeLog("Remove file '" + source + "'");
      }
    } else {
      throw e;
    }
  };
  sync = function() {
    clearTimeout(syncTimeout);
    return syncTimeout = wait(25, function() {
      return fs.stat(source, function(err, stats) {
        if (err) {
          return watchErr(err);
        }
        if (prevStats && stats.size === prevStats.size && stats.mtime.getTime() === prevStats.mtime.getTime()) {
          return rewatch();
        }
        prevStats = stats;
        return syncFile(source, base, function() {
          if (options.server) {
            restartServer();
          }
          return rewatch();
        }, true, symbolicLink);
      });
    });
  };
  try {
    watcher = fs.watch(source, sync);
  } catch (e) {
    watchErr(e);
  }
  return rewatch = function() {
    if (watcher != null) {
      watcher.close();
    }
    return watcher = fs.watch(source, sync);
  };
};

watchDir = function(source, base) {
  var readdirTimeout, watcher;
  readdirTimeout = null;
  try {
    return watcher = fs.watch(source, function() {
      clearTimeout(readdirTimeout);
      return readdirTimeout = wait(25, function() {
        return fs.readdir(source, function(err, files) {
          var file, _i, _len, _results;
          if (err) {
            if (err.code !== 'ENOENT') {
              throw err;
            }
            watcher.close();
            return unwatchDir(source, base);
          }
          _results = [];
          for (_i = 0, _len = files.length; _i < _len; _i++) {
            file = files[_i];
            file = path.join(source, file);
            if (sources.some(function(s) {
              return s.indexOf(file) >= 0;
            })) {
              continue;
            }
            Cordjs.utils.timeLog("Add file '" + source + "'");
            sources.push(file);
            _results.push(syncFiles(file, base));
          }
          return _results;
        });
      });
    });
  } catch (e) {
    if (e.code !== 'ENOENT') {
      throw e;
    }
  }
};

unwatchDir = function(source, base) {
  var file, prevSources, toRemove, _i, _len;
  prevSources = sources.slice(0);
  toRemove = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = sources.length; _i < _len; _i++) {
      file = sources[_i];
      if (file.indexOf(source) >= 0) {
        _results.push(file);
      }
    }
    return _results;
  })();
  for (_i = 0, _len = toRemove.length; _i < _len; _i++) {
    file = toRemove[_i];
    removeSource(file, base, true);
  }
  if (!sources.some(function(s, i) {
    return prevSources[i] !== s;
  })) {

  }
};

removeSource = function(source, base, remove) {
  var index, outPath;
  index = sources.indexOf(source);
  sources.splice(index, 1);
  if (remove) {
    outPath = outputPath(source, base);
    return exists(outPath, function(itExists) {
      if (itExists) {
        return fs.unlink(outPath, function(err) {
          if (err && err.code !== 'ENOENT') {
            throw err;
          }
          return Cordjs.utils.timeLog("removed " + source);
        });
      }
    });
  }
};

removeDirSync = function(source) {
  var file, filename, stat, _i, _len, _ref1;
  try {
    _ref1 = fs.readdirSync(source);
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      file = _ref1[_i];
      filename = path.join(source, file);
      stat = fs.statSync(filename);
      if (filename === "." || filename === "..") {
        continue;
      }
      if (stat.isDirectory()) {
        removeDirSync(filename);
      } else {
        fs.unlinkSync(filename);
      }
    }
    return fs.rmdirSync(source);
  } catch (e) {
    if (e.code !== 'ENOENT') {
      throw e;
    }
  }
};

outputPath = function(source, base) {
  var baseDir, dir, filename, srcDir;
  filename = path.basename(source);
  srcDir = path.dirname(source);
  baseDir = srcDir;
  dir = path.join(outputDir, baseDir);
  return path.join(dir, filename);
};

parseOptions = function(args) {
  var o, optionParser;
  optionParser = new optparse.OptionParser(OptionsList, EmptyArguments);
  o = options = optionParser.parse(args);
  if (options.autorestart) {
    options.server = options.watch = true;
  }
  if (o["arguments"].length) {
    return publicDir = o["arguments"][0];
  }
};

usage = function() {
  return printLine((new optparse.OptionParser(OptionsList, EmptyArguments)).help());
};

version = function() {
  return printLine("Cordjs current version: " + Cordjs.VERSION);
};

wait = function(milliseconds, func) {
  return setTimeout(func, milliseconds);
};

exists = fs.exists || path.exists;

hidden = function(file) {
  return /\/\.|~$/.test(file) || /^\.|~$/.test(file);
};

printLine = function(line) {
  return process.stdout.write(line + '\n');
};

printWarn = function(line) {
  return process.stderr.write(line + '\n');
};
