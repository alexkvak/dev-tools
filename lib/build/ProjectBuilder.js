// Generated by CoffeeScript 1.6.3
var EventEmitter, Future, ProjectBuilder, buildManager, fs, getFileInfo, makeDestinationFile, path, requirejs, sourceModified, walk,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

path = require('path');

fs = require('fs');

requirejs = require('requirejs');

walk = require('walk');

EventEmitter = require('events').EventEmitter;

Future = require('../utils/Future');

buildManager = require('./BuildManager');

ProjectBuilder = (function(_super) {
  __extends(ProjectBuilder, _super);

  /*
  Builds the whole cordjs application project
  */


  function ProjectBuilder(params) {
    this.params = params;
    console.log("build params", this.params);
  }

  ProjectBuilder.prototype.build = function() {
    var appConfFile, appConfPromise, completePromise, corePromise, pathUtilsPromise, relativePos, scanBundle, scanCore, scanDir, scanRegularDir, start, widgetClassesPromise,
      _this = this;
    console.log("building project...");
    start = process.hrtime();
    completePromise = new Future(1);
    corePromise = new Future(1);
    widgetClassesPromise = new Future(1);
    relativePos = this.params.baseDir.length + 1;
    scanDir = function(dir, payloadCallback) {
      var walker,
        _this = this;
      completePromise.fork();
      walker = walk.walk(dir);
      walker.on('file', function(root, stat, next) {
        var relativeDir;
        if (root.indexOf('.git') < 0 && stat.name.indexOf('.git') < 0 && root.indexOf('.hg') < 0 && stat.name.indexOf('.hg') < 0) {
          relativeDir = root.substr(relativePos);
          payloadCallback("" + relativeDir + "/" + stat.name, stat);
          return setTimeout(next, 0);
        } else {
          return next();
        }
      });
      walker.on('end', function() {
        console.log("walker for dir " + dir + " completed!");
        return completePromise.resolve();
      });
      return walker;
    };
    scanRegularDir = function(dir) {
      return scanDir(dir, function(relativeName, stat) {
        var info;
        info = getFileInfo(relativeName);
        return sourceModified(relativeName, stat, _this.params.targetDir, info).map(function(modified) {
          if (modified) {
            return completePromise.when(buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, getFileInfo(relativeName)));
          }
        });
      });
    };
    scanCore = function() {
      return scanDir("" + _this.params.baseDir + "/public/bundles/cord/core", function(relativeName, stat) {
        var info;
        info = getFileInfo(relativeName, 'cord/core');
        return sourceModified(relativeName, stat, _this.params.targetDir, info).map(function(modified) {
          var task;
          if (modified) {
            if (info.inWidgets) {
              if (info.isWidget) {
                task = corePromise.flatMap(function() {
                  return buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info);
                });
                completePromise.when(task);
                return widgetClassesPromise.when(task);
              } else if (info.isWidgetTemplate) {
                return widgetClassesPromise.flatMap(function() {
                  return buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info);
                }).link(completePromise);
              } else if (info.isStylus) {
                return pathUtilsPromise.flatMap(function() {
                  return buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info);
                }).link(completePromise);
              } else {
                return buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info).link(completePromise);
              }
            } else {
              task = buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info);
              corePromise.when(task);
              return completePromise.when(task);
            }
          }
        }).link(corePromise);
      }).on('end', function() {
        return corePromise.resolve();
      });
    };
    scanBundle = function(bundle) {
      widgetClassesPromise.fork();
      return scanDir("" + _this.params.baseDir + "/public/bundles/" + bundle, function(relativeName, stat) {
        var info;
        info = getFileInfo(relativeName, bundle);
        return sourceModified(relativeName, stat, _this.params.targetDir, info).map(function(modified) {
          var task;
          if (modified) {
            if (info.isWidget) {
              task = corePromise.flatMap(function() {
                return buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info);
              });
              completePromise.when(task);
              return widgetClassesPromise.when(task);
            } else if (info.isWidgetTemplate) {
              return widgetClassesPromise.flatMap(function() {
                return buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info);
              }).link(completePromise);
            } else if (info.isStylus) {
              return pathUtilsPromise.flatMap(function() {
                return buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info);
              }).link(completePromise);
            } else {
              return buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info).link(completePromise);
            }
          }
        });
      }).on('end', function() {
        return widgetClassesPromise.resolve();
      });
    };
    appConfFile = 'public/app/application';
    appConfPromise = buildManager.createTask("" + appConfFile + ".coffee", this.params.baseDir, this.params.targetDir, getFileInfo("" + appConfFile + ".coffee"));
    pathUtilsPromise = buildManager.createTask('public/bundles/cord/core/requirejs/pathUtils.coffee', this.params.baseDir, this.params.targetDir, getFileInfo('public/bundles/cord/core/requirejs/pathUtils.coffee', 'cord/core'));
    scanRegularDir(this.params.baseDir + '/public/vendor');
    scanRegularDir(this.params.baseDir + '/conf');
    buildManager.createTask('server.coffee', this.params.baseDir, this.params.targetDir, getFileInfo('server.coffee')).link(completePromise);
    appConfPromise.done(function() {
      scanCore();
      requirejs.config({
        baseUrl: _this.params.targetDir
      });
      return requirejs([appConfFile], function(bundles) {
        var bundle, _i, _len;
        for (_i = 0, _len = bundles.length; _i < _len; _i++) {
          bundle = bundles[_i];
          scanBundle(bundle);
        }
        widgetClassesPromise.resolve();
        return completePromise.resolve();
      });
    });
    completePromise.done(function() {
      var diff;
      diff = process.hrtime(start);
      console.log("Build complete in " + ((diff[0] * 1e9 + diff[1]) / 1e6) + " ms");
      return buildManager.stop();
    });
    return this;
  };

  return ProjectBuilder;

})(EventEmitter);

getFileInfo = function(file, bundle) {
  /*
  Returns a lot of file properties from the framework's point of view
  @param String file path to file
  @param (optional)String bundle bundle to which this file belongs
  @return Object key-value with file properties
  */

  var bundleOk, bundleParts, ext, fileName, fileWithoutExt, i, inBundleIndex, inBundles, inModels, inPublic, inTemplates, inWidgets, isBehaviour, isWidget, isWidgetTemplate, lastDirName, lowerName, p, parts, _i, _len;
  parts = file.split(path.sep);
  inPublic = parts[0] === 'public';
  fileName = parts.pop();
  lastDirName = parts[parts.length - 1];
  ext = path.extname(fileName);
  fileWithoutExt = fileName.slice(0, -ext.length);
  if (inPublic) {
    inBundles = parts[1] === 'bundles';
    if (inBundles) {
      bundleParts = bundle.split('/');
      bundleOk = true;
      for (i = _i = 0, _len = bundleParts.length; _i < _len; i = ++_i) {
        p = bundleParts[i];
        if (p !== parts[2 + i]) {
          bundleOk = false;
          break;
        }
      }
      if (bundleOk) {
        inBundleIndex = 2 + bundleParts.length;
        inWidgets = parts[inBundleIndex] === 'widgets';
        inTemplates = parts[inBundleIndex] === 'templates';
        inModels = parts[inBundleIndex] === 'models';
        if (inWidgets) {
          if (ext === '.coffee') {
            lowerName = fileWithoutExt.charAt(0).toLowerCase() + fileWithoutExt.slice(1);
            isWidget = lastDirName === lowerName;
            isBehaviour = (lastDirName + 'Behaviour') === lowerName;
          } else if (ext === '.html') {
            isWidgetTemplate = lastDirName === fileWithoutExt;
          }
        }
      }
    } else {
      bundle = null;
    }
  }
  return {
    fileName: fileName,
    ext: ext,
    fileNameWithoutExt: fileWithoutExt,
    lastDirName: lastDirName,
    bundle: bundle,
    inPublic: inPublic,
    inBundles: inBundles != null ? inBundles : false,
    inWidgets: inWidgets != null ? inWidgets : false,
    inTemplates: inTemplates != null ? inTemplates : false,
    inModels: inModels != null ? inModels : false,
    isWidget: isWidget != null ? isWidget : false,
    isBehaviour: isBehaviour != null ? isBehaviour : false,
    isWidgetTemplate: isWidgetTemplate != null ? isWidgetTemplate : false,
    isCoffee: ext === '.coffee',
    isHtml: ext === '.html',
    isStylus: ext === '.styl'
  };
};

sourceModified = function(file, srcStat, targetDir, info) {
  /*
  Asynchronously returns true if destination built file modification time is earlier than the source
   (file need to be recompiled)
  @param String file relative file name
  @param StatInfo srcStat result of stat-call for the source file
  @param String targetDir base directory for destination file
  @param Object info framework-related information about the file
  @return Future[Boolean]
  */

  var dstPath;
  dstPath = path.join(targetDir, makeDestinationFile(file, info));
  return Future.call(fs.stat, dstPath).map(function(dstStat) {
    return srcStat.mtime.getTime() > dstStat.mtime.getTime();
  }).failMap(function() {
    return true;
  });
};

makeDestinationFile = function(file, info) {
  /*
  Returns destination file relative name based on source file and framework-related information
  @param String file relative file name
  @param Object info framework-related information about the file
  @return String
  */

  if (info.isCoffee) {
    return path.dirname(file) + path.sep + info.fileNameWithoutExt + '.js';
  } else if (info.isStylus) {
    return path.dirname(file) + path.sep + info.fileNameWithoutExt + '.css';
  } else if (info.isWidgetTemplate) {
    return file + '.js';
  } else {
    return file;
  }
};

module.exports = ProjectBuilder;
