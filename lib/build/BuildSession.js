// Generated by CoffeeScript 1.6.3
var BuildSession, Future, buildManager, fileInfo, fs, path, requirejs;

fs = require('fs');

path = require('path');

requirejs = require('requirejs');

Future = require('../utils/Future');

buildManager = require('./BuildManager');

fileInfo = require('./FileInfo');

BuildSession = (function() {
  /*
  Organizes build of the applied files in the right order sequence in terms of cordjs framework.
  */

  BuildSession.APP_CONF_FILE = 'public/app/application';

  BuildSession.prototype._completePromise = null;

  BuildSession.prototype._corePromise = null;

  BuildSession.prototype._widgetClassesPromise = null;

  BuildSession.prototype._appConfPromise = null;

  BuildSession.prototype._pathUtilsPromise = null;

  BuildSession.prototype._relativePos = 0;

  function BuildSession(params) {
    this.params = params;
    this._relativePos = this.params.baseDir.length + 1;
    this._completePromise = new Future(1);
    this._corePromise = new Future(1);
    this._widgetClassesPromise = new Future(1);
    this._appConfPromise = new Future(1);
    this._pathUtilsPromise = new Future(1);
    this._completePromise.when(this._appConfPromise, this._pathUtilsPromise);
  }

  BuildSession.prototype.add = function(file) {
    /*
    Adds file to the build session
    @param String file absolute file path
    @return Future
    */

    var _this = this;
    file = file.substr(this._relativePos);
    if (file === BuildSession.APP_CONF_FILE + '.coffee') {
      this._appConfPromise.fork();
      return this._handleFile(file).done(function() {
        requirejs.config({
          baseUrl: _this.params.targetDir
        });
        return requirejs([BuildSession.APP_CONF_FILE], function(bundles) {
          _this._handleBundlesChange(bundles);
          return _this._appConfPromise.resolve();
        });
      });
    } else if (file === BuildSession.PATH_UTILS_FILE) {
      return this._handleFile(file, 'cord/core').link(this._pathUtilsPromise);
    } else {
      return this._appConfPromise.andThen(function() {
        return _this._handleFile(file, fileInfo.detectBundle(file)).mapFail(function() {
          console.error("Build task failed for\n" + file);
          return null;
        }).link(_this._completePromise);
      }).link(this._completePromise);
    }
  };

  BuildSession.prototype.complete = function() {
    /*
    Indicates that all files are added for this session.
    @return Future completes when the build session is completed
    */

    this._appConfPromise.resolve();
    this._pathUtilsPromise.resolve();
    this._corePromise.resolve();
    this._widgetClassesPromise.resolve();
    this._completePromise.resolve();
    return this._completePromise;
  };

  BuildSession.prototype._handleBundlesChange = function(bundles) {
    /*
    Calculates bundles diff, removes old bundles from build, adds new bundles files to build
    */

  };

  BuildSession.prototype._handleFile = function(file, bundle) {
    var info,
      _this = this;
    info = fileInfo.getFileInfo(file, bundle);
    if (info.isStylus) {
      return this._pathUtilsPromise.flatMap(function() {
        return _this._createTask(file, info);
      });
    } else if (info.inWidgets) {
      if (info.isWidget) {
        return this._corePromise.flatMap(function() {
          return _this._createTask(file, info);
        }).link(this._widgetClassesPromise);
      } else if (info.isWidgetTemplate) {
        return this._widgetClassesPromise.flatMap(function() {
          return _this._createTask(file, info);
        });
      } else {
        return this._createTask(file, info);
      }
    } else if (bundle === 'cord/core') {
      return this._createTask(file, info).link(this._corePromise);
    } else {
      return this._createTask(file, info);
    }
  };

  BuildSession.prototype._createTask = function(file, info) {
    var _this = this;
    return this._sourceModified(file, info).flatMap(function(modified) {
      if (modified) {
        return buildManager.createTask(file, _this.params.baseDir, _this.params.targetDir, info);
      } else {
        return Future.resolved();
      }
    });
  };

  BuildSession.prototype._sourceModified = function(file, info) {
    /*
    Asynchronously returns true if destination built file modification time is earlier than the source
     (file need to be recompiled)
    @param String file relative file name
    @param Object info framework-related information about the file
    @return Future[Boolean]
    */

    var dstPath, srcPath;
    srcPath = path.join(this.params.baseDir, file);
    dstPath = path.join(this.params.targetDir, fileInfo.getBuildDestinationFile(file, info));
    return Future.call(fs.stat, srcPath).zip(Future.call(fs.stat, dstPath)).map(function(srcStat, dstStat) {
      return srcStat.mtime.getTime() > dstStat.mtime.getTime();
    }).mapFail(function() {
      return true;
    });
  };

  return BuildSession;

})();

module.exports = BuildSession;
