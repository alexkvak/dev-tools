// Generated by CoffeeScript 1.6.3
var ByWidgetGroupDetector, CorrelationGroupDetector, Future, GroupRepo, HeuristicGroupDetector, Optimizer, UglifyJS, coffeeUtilCode, fs, mkdirp, sha1, _;

fs = require('fs');

_ = require('underscore');

mkdirp = require('mkdirp');

UglifyJS = require('uglify-js');

Future = require('../utils/Future');

sha1 = require('../utils/sha1');

ByWidgetGroupDetector = require('./ByWidgetGroupDetector');

CorrelationGroupDetector = require('./CorrelationGroupDetector');

GroupRepo = require('./GroupRepo');

HeuristicGroupDetector = require('./HeuristicGroupDetector');

coffeeUtilCode = ['__hasProp = {}.hasOwnProperty', '__extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }', '__bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; }', '__slice = [].slice', '__indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; }'];

Optimizer = (function() {
  function Optimizer() {}

  Optimizer.prototype.run = function() {
    var statFile,
      _this = this;
    statFile = 'require-stat.json';
    return fs.readFile(statFile, function(err, data) {
      var stat;
      stat = err ? {} : JSON.parse(data);
      return console.log(JSON.stringify(_this.generateOptimizationMap(stat), null, 2));
    });
  };

  Optimizer.prototype.generateOptimizationMap = function(stat) {
    var corrDetector, group, groupId, groupRepo, groups, heuristicDetector, iterations, page, resultMap, widgetDetector, _i, _len;
    iterations = 1;
    groupRepo = new GroupRepo;
    widgetDetector = new ByWidgetGroupDetector(groupRepo);
    stat = widgetDetector.process(stat);
    while (iterations--) {
      corrDetector = new CorrelationGroupDetector(groupRepo);
      stat = corrDetector.process(stat);
      heuristicDetector = new HeuristicGroupDetector(groupRepo);
      stat = heuristicDetector.process(stat);
    }
    resultMap = {};
    for (page in stat) {
      groups = stat[page];
      for (_i = 0, _len = groups.length; _i < _len; _i++) {
        groupId = groups[_i];
        group = groupRepo.getGroup(groupId);
        if (group) {
          resultMap[groupId] = _.uniq(group.getModules());
        }
      }
    }
    return this._mergeGroups(resultMap);
  };

  Optimizer.prototype._mergeGroups = function(groupsMap) {
    var groupId, modules, result, resultMap, _fn,
      _this = this;
    result = new Future(1);
    resultMap = {};
    _fn = function(modules) {
      result.fork();
      return _this._mergeGroup(modules).done(function(fileName) {
        resultMap[fileName] = modules;
        return result.resolve();
      });
    };
    for (groupId in groupsMap) {
      modules = groupsMap[groupId];
      _fn(modules);
    }
    return result.resolve().map(function() {
      return resultMap;
    });
  };

  Optimizer.prototype._mergeGroup = function(modules) {
    var csUtilHit, futures, mergedContent, module;
    mergedContent = '';
    csUtilHit = {};
    futures = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = modules.length; _i < _len; _i++) {
        module = modules[_i];
        _results.push((function(module) {
          return Future.call(fs.readFile, "target/public/" + module + ".js", 'utf8').map(function(js) {
            var code, i, _j, _len1;
            js = js.replace('define(', "define('" + module + "',");
            for (i = _j = 0, _len1 = coffeeUtilCode.length; _j < _len1; i = ++_j) {
              code = coffeeUtilCode[i];
              if (js.indexOf(code) > -1) {
                js = js.replace(code + ",\n  ", '');
                js = js.replace(code, '');
                csUtilHit[i] = true;
              }
            }
            js = js.replace("var ;\n", '');
            mergedContent += js + "\n\n";
            return true;
          }).mapFail(function() {
            return false;
          });
        })(module));
      }
      return _results;
    })();
    return Future.call(mkdirp, 'target/public/assets/z').zip(Future.sequence(futures)).flatMap(function() {
      var fileName, hit, i, resultCode;
      hit = Object.keys(csUtilHit);
      if (hit.length > 0) {
        resultCode = 'var ' + ((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = hit.length; _i < _len; _i++) {
            i = hit[_i];
            _results.push(coffeeUtilCode[i]);
          }
          return _results;
        })()).join(',\n  ') + ';\n\n';
        mergedContent = resultCode + mergedContent;
      }
      fileName = sha1(mergedContent);
      return Future.call(fs.writeFile, "target/public/assets/z/" + fileName + ".js", mergedContent).map(function() {
        return fileName;
      });
    });
  };

  return Optimizer;

})();

module.exports = Optimizer;
