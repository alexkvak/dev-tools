// Generated by CoffeeScript 1.6.3
var BuildWorker, Future, fork;

fork = require('child_process').fork;

Future = require('../utils/Future').Future;

BuildWorker = (function() {
  /*
  Build worker process representation on the main build process side.
  */

  BuildWorker.MAX_SENDING_TASKS = 3;

  BuildWorker.IDLE_STOP_TIMEOUT = 1000;

  BuildWorker._idCounter = 0;

  BuildWorker.prototype.id = 0;

  BuildWorker.prototype._process = null;

  BuildWorker.prototype._tasks = null;

  BuildWorker.prototype._sendingTask = 0;

  BuildWorker.prototype._acceptReady = null;

  BuildWorker.prototype._workload = 0;

  BuildWorker.prototype._taskCounter = 0;

  BuildWorker.prototype.totalTasksCount = 0;

  BuildWorker.prototype._killTimeout = null;

  function BuildWorker(manager) {
    var _this = this;
    this.manager = manager;
    this.id = ++BuildWorker._idCounter;
    this._process = fork(__dirname + '/build-worker.js');
    this._acceptReady = Future.resolved(this);
    this._tasks = {};
    this._process.on('message', function(m) {
      if (m.workload != null) {
        _this._workload = m.workload;
      }
      switch (m.type) {
        case 'accepted':
          if (!_this.canAcceptTask()) {
            _this._sendingTask--;
            return _this._acceptReady.resolve(_this);
          } else {
            return _this._sendingTask--;
          }
          break;
        case 'completed':
          _this._tasks[m.task].resolve();
          delete _this._tasks[m.task];
          _this._taskCounter--;
          if (_this._taskCounter === 0) {
            return _this._killTimeout = setTimeout(function() {
              if (_this._taskCounter === 0) {
                return _this.stop();
              }
            }, BuildWorker.IDLE_STOP_TIMEOUT);
          }
      }
    });
  }

  BuildWorker.prototype.addTask = function(taskParams) {
    /*
    @return Future[Nothing]
    */

    if (this.canAcceptTask()) {
      this._tasks[taskParams.id] = Future.single();
      this._process.send(taskParams);
      this._sendingTask++;
      if (!this.canAcceptTask()) {
        this._acceptReady = Future.single();
      }
      this._taskCounter++;
      this.totalTasksCount++;
      if (this._killTimeout) {
        clearTimeout(this._killTimeout);
      }
      return this._tasks[taskParams.id];
    } else {
      throw new Error("Can't accept task now!");
    }
  };

  BuildWorker.prototype.stop = function() {
    /*
    Kills worker process and stops this worker.
    */

    this._process.kill();
    return this.manager.stopWorker(this);
  };

  BuildWorker.prototype.canAcceptTask = function() {
    return this._sendingTask < BuildWorker.MAX_SENDING_TASKS;
  };

  BuildWorker.prototype.acceptReady = function() {
    return this._acceptReady;
  };

  BuildWorker.prototype.getWorkload = function() {
    return this._workload * this._taskCounter + 1;
  };

  return BuildWorker;

})();

exports.BuildWorker = BuildWorker;
