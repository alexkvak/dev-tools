// Generated by CoffeeScript 1.6.3
var BuildSession, EventEmitter, Future, ProjectBuilder, ProjectWatcher, buildManager, fileInfo, fs, path, requirejs, rmrf, sourceModified, walk, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

path = require('path');

fs = require('fs');

requirejs = require('requirejs');

walk = require('walk');

EventEmitter = require('events').EventEmitter;

_ = require('underscore');

Future = require('../utils/Future');

rmrf = require('../utils/rmrf');

buildManager = require('./BuildManager');

BuildSession = require('./BuildSession');

fileInfo = require('./FileInfo');

ProjectWatcher = require('./ProjectWatcher');

ProjectBuilder = (function(_super) {
  __extends(ProjectBuilder, _super);

  /*
  Builds the whole cordjs application project
  */


  ProjectBuilder.prototype._emitCompletePromise = null;

  function ProjectBuilder(params) {
    this.params = params;
    fileInfo.setDirs(this.params.baseDir, this.params.targetDir);
    if (this.params.watch) {
      this.setupWatcher();
    }
  }

  ProjectBuilder.prototype._walkerFilter = function(dir, name) {
    /*
    Filters hidden and temporary files from being handled by the builder.
    @param String dir dirname
    @param String name basename
    @return Boolean true if the file is OK for building, false if it should be skipped
    */

    var ext;
    if (name.charAt(0) === '.') {
      return false;
    } else {
      ext = path.extname(name);
      if (ext === '.orig' || ext.substr(-1) === '~') {
        return false;
      } else {
        return dir.indexOf(path.sep + '.') === -1;
      }
    }
  };

  ProjectBuilder.prototype.build = function() {
    var appConfFile, appConfPromise, completePromise, corePromise, nonWidgetFilesPromise, pathUtilsPromise, relativePos, scanBundle, scanCore, scanDir, scanRegularDir, start, widgetClassesPromise,
      _this = this;
    console.log("Building project (full scan)...");
    start = process.hrtime();
    completePromise = new Future(1);
    corePromise = new Future(1);
    widgetClassesPromise = new Future(1);
    nonWidgetFilesPromise = new Future(1);
    relativePos = this.params.baseDir.length + 1;
    scanDir = function(dir, payloadCallback) {
      var walker;
      completePromise.done(function() {
        return _this.watchDir(dir);
      });
      completePromise.fork();
      walker = walk.walk(dir);
      walker.on('file', function(root, stat, next) {
        var relativeDir;
        if (_this._walkerFilter(root, stat.name)) {
          relativeDir = root.substr(relativePos);
          payloadCallback("" + relativeDir + "/" + stat.name, stat);
          return setTimeout(next, 0);
        } else {
          return next();
        }
      });
      walker.on('symbolicLink', function(root, stat, next) {
        var relativeDir;
        if (_this._walkerFilter(root, stat.name)) {
          relativeDir = root.substr(relativePos);
          payloadCallback("" + relativeDir + "/" + stat.name, stat);
        }
        return next();
      });
      if (_this.params.watch) {
        walker.on('directory', function(root, stat, next) {
          if (_this._walkerFilter(root, stat.name)) {
            completePromise.done(function() {
              return _this.watchDir("" + root + "/" + stat.name);
            });
          }
          return next();
        });
      }
      walker.on('end', function() {
        console.log("walker for dir " + dir + " completed!");
        return completePromise.resolve();
      });
      return walker;
    };
    scanRegularDir = function(dir) {
      return scanDir(dir, function(relativeName, stat) {
        var info;
        info = fileInfo.getFileInfo(relativeName);
        completePromise.fork();
        return sourceModified(relativeName, stat, _this.params.targetDir, info).map(function(modified) {
          if (modified) {
            completePromise.when(buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info));
          }
          return completePromise.resolve();
        });
      });
    };
    scanCore = function() {
      return scanDir("" + _this.params.baseDir + "/public/bundles/cord/core", function(relativeName, stat) {
        var info;
        info = fileInfo.getFileInfo(relativeName, 'cord/core');
        completePromise.fork();
        return sourceModified(relativeName, stat, _this.params.targetDir, info).map(function(modified) {
          var task;
          if (modified) {
            if (info.inWidgets) {
              if (info.isWidget) {
                task = corePromise.flatMap(function() {
                  return buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info);
                });
                completePromise.when(task);
                widgetClassesPromise.when(task);
              } else if (info.isWidgetTemplate) {
                widgetClassesPromise.flatMap(function() {
                  return buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info);
                }).link(completePromise);
              } else if (info.isStylus) {
                pathUtilsPromise.flatMap(function() {
                  return buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info);
                }).link(completePromise);
              } else {
                buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info).link(completePromise);
              }
            } else {
              task = buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info);
              corePromise.when(task);
              completePromise.when(task);
            }
          }
          return completePromise.resolve();
        }).link(corePromise);
      }).on('end', function() {
        return corePromise.resolve();
      });
    };
    scanBundle = function(bundle) {
      widgetClassesPromise.fork();
      nonWidgetFilesPromise.fork();
      return scanDir("" + _this.params.baseDir + "/public/bundles/" + bundle, function(relativeName, stat) {
        var info;
        info = fileInfo.getFileInfo(relativeName, bundle);
        completePromise.fork();
        return sourceModified(relativeName, stat, _this.params.targetDir, info).map(function(modified) {
          var task;
          if (modified) {
            if (info.isWidget) {
              task = corePromise.flatMap(function() {
                return buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info);
              });
              completePromise.when(task);
              widgetClassesPromise.when(task);
            } else if (info.isWidgetTemplate) {
              widgetClassesPromise.zip(nonWidgetFilesPromise).flatMap(function() {
                return buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info);
              }).link(completePromise);
            } else if (info.isCoffee && !info.inWidgets) {
              buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info).link(completePromise).link(nonWidgetFilesPromise);
            } else if (info.isStylus) {
              pathUtilsPromise.flatMap(function() {
                return buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info);
              }).link(completePromise);
            } else {
              buildManager.createTask(relativeName, _this.params.baseDir, _this.params.targetDir, info).link(completePromise);
            }
          }
          return completePromise.resolve();
        });
      }).on('end', function() {
        widgetClassesPromise.resolve();
        return nonWidgetFilesPromise.resolve();
      });
    };
    appConfFile = 'public/app/application';
    appConfPromise = buildManager.createTask("" + appConfFile + ".coffee", this.params.baseDir, this.params.targetDir, fileInfo.getFileInfo("" + appConfFile + ".coffee"));
    pathUtilsPromise = buildManager.createTask('public/bundles/cord/core/requirejs/pathUtils.coffee', this.params.baseDir, this.params.targetDir, fileInfo.getFileInfo('public/bundles/cord/core/requirejs/pathUtils.coffee', 'cord/core'));
    scanRegularDir(this.params.baseDir + '/public/vendor');
    scanRegularDir(this.params.baseDir + '/conf');
    buildManager.createTask('server.coffee', this.params.baseDir, this.params.targetDir, fileInfo.getFileInfo('server.coffee')).link(completePromise);
    appConfPromise.done(function() {
      scanCore();
      requirejs.config({
        baseUrl: _this.params.targetDir
      });
      return requirejs([appConfFile], function(bundles) {
        var bundle, _i, _len;
        fileInfo.setBundles(bundles);
        for (_i = 0, _len = bundles.length; _i < _len; _i++) {
          bundle = bundles[_i];
          scanBundle(bundle);
        }
        widgetClassesPromise.resolve();
        nonWidgetFilesPromise.resolve();
        return completePromise.resolve();
      });
    });
    completePromise.done(function() {
      var diff;
      diff = process.hrtime(start);
      console.log("Build complete in " + ((diff[0] * 1e9 + diff[1]) / 1e6) + " ms");
      buildManager.stop();
      return _this.emit('complete');
    });
    this._previousSessionPromise = completePromise;
    return this;
  };

  ProjectBuilder.prototype.setupWatcher = function() {
    var _this = this;
    this.watcher = new ProjectWatcher(this.params.baseDir);
    return this.watcher.on('change', function(changes) {
      var currentSessionPromise;
      if (_this._emitCompletePromise == null) {
        _this._emitCompletePromise = new Future;
        _this._emitCompletePromise.fork();
        _this._emitCompletePromise.done(function() {
          _this.emit('complete');
          return _this._emitCompletePromise = null;
        });
      } else {
        _this._emitCompletePromise.fork();
      }
      currentSessionPromise = _this._previousSessionPromise.flatMap(function() {
        var removed, rmList;
        rmList = (function() {
          var _i, _len, _ref, _results;
          _ref = _.sortBy(changes.removed, function(f) {
            return f.length;
          }).reverse();
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            removed = _ref[_i];
            console.log("removing " + removed + "...");
            _results.push(rmrf(fileInfo.getTargetForSource(removed)).failAloud());
          }
          return _results;
        })();
        return Future.sequence(rmList).flatMap(function() {
          var buildSession, file, scanCompletePromise, scanDir, sessionCompletePromise, stat, _ref;
          buildSession = new BuildSession(_this.params);
          sessionCompletePromise = Future.single();
          scanDir = function(dir) {
            var result, walker;
            result = Future.single();
            sessionCompletePromise.done(function() {
              return _this.watchDir(dir);
            });
            walker = walk.walk(dir);
            walker.on('file', function(root, stat, next) {
              if (_this._walkerFilter(root, stat.name)) {
                buildSession.add(path.join(root, stat.name));
              }
              return next();
            });
            walker.on('symbolicLink', function(root, stat, next) {
              if (_this._walkerFilter(root, stat.name)) {
                buildSession.add(path.join(root, stat.name));
              }
              return next();
            });
            walker.on('directory', function(root, stat, next) {
              if (_this._walkerFilter(root, stat.name)) {
                sessionCompletePromise.done(function() {
                  return _this.watchDir("" + root + "/" + stat.name);
                });
              }
              return next();
            });
            walker.on('end', function() {
              console.log("walker for dir " + dir + " completed!");
              return result.resolve();
            });
            return result;
          };
          scanCompletePromise = new Future;
          _ref = changes.changed;
          for (file in _ref) {
            stat = _ref[file];
            if (stat.isFile()) {
              buildSession.add(file);
            } else if (stat.isDirectory()) {
              scanCompletePromise.when(scanDir(file));
            }
          }
          return scanCompletePromise.flatMap(function() {
            return sessionCompletePromise.when(buildSession.complete());
          }).done(function() {
            return _this._emitCompletePromise.resolve();
          });
        });
      });
      return _this._previousSessionPromise = currentSessionPromise;
    });
  };

  ProjectBuilder.prototype.watchDir = function(dir) {
    if (this.params.watch) {
      return this.watcher.addDir(dir);
    }
  };

  return ProjectBuilder;

})(EventEmitter);

sourceModified = function(file, srcStat, targetDir, info) {
  /*
  Asynchronously returns true if destination built file modification time is earlier than the source
   (file need to be recompiled)
  @param String file relative file name
  @param StatInfo srcStat result of stat-call for the source file
  @param String targetDir base directory for destination file
  @param Object info framework-related information about the file
  @return Future[Boolean]
  */

  var dstPath;
  dstPath = path.join(targetDir, fileInfo.getBuildDestinationFile(file, info));
  return Future.call(fs.stat, dstPath).map(function(dstStat) {
    return srcStat.mtime.getTime() > dstStat.mtime.getTime();
  }).mapFail(function() {
    return true;
  });
};

module.exports = ProjectBuilder;
