// Generated by CoffeeScript 1.3.3
(function() {
  var CoffeeScript, Cordjs, EmptyArguments, OptionsList, aFiles, addWidgetWaitCompiler, baseDirFull, basePath, compileWidget, copyFile, create, createDir, exec, exists, fs, getWidgetPath, hidden, isDiffSource, mainCommand, options, optparse, otherCommand, outputDir, outputPath, parseOptions, path, pathToCore, pathToNodeInit, printLine, printWarn, publicDir, removeDirSync, removeSource, requirejs, restartServer, serverChild, sources, spawn, startServer, stopServer, syncFile, syncFiles, testCommandDir, timeEnd, timeStart, unwatchDir, usage, util, version, wait, walk, watchDir, watchFile, widgetsWaitComliler, _endTimer, _ref, _startTimer;

  fs = require('fs');

  util = require('util');

  path = require('path');

  walk = require('walk');

  optparse = require('./optparse');

  _ref = require('child_process'), spawn = _ref.spawn, exec = _ref.exec;

  Cordjs = require('./cordjs');

  CoffeeScript = require('./coffee-script');

  util = require('util');

  requirejs = require('requirejs');

  publicDir = basePath = 'public';

  outputDir = 'target';

  options = {};

  sources = [];

  widgetsWaitComliler = [];

  aFiles = {
    sync: [],
    copy: []
  };

  baseDirFull = null;

  serverChild = null;

  timeStart = timeEnd = null;

  pathToCore = "/bundles/cord/core/";

  pathToNodeInit = "" + pathToCore + "nodeInit";

  EmptyArguments = (" " + 'Usage:'.bold + " cordjs [options] path/to/project -- [args] ").inverse;

  OptionsList = [['-a', '--autorestart', 'autorestart server'], ['-b', '--build', 'build project'], ['-c', '--clean', 'clean target'], ['-d', '--dev', 'development mode - copy all files to the outputDir'], ['-h', '--help', 'display this help message'], ['-o', '--output [DIR]', 'output directory'], ['-s', '--server', 'start server'], ['-v', '--version', 'display the version number'], ['-w', '--watch', 'watch scripts for changes and rerun commands']];

  exports.run = function() {
    var args, command, type;
    args = process.argv.slice(2);
    type = args.shift().split(':');
    command = type[1];
    if (command != null) {
      return otherCommand(type[0], command, args);
    } else {
      parseOptions(process.argv.slice(2));
      if (options.help) {
        return usage();
      }
      if (options.version) {
        return version();
      }
      if (options.output) {
        outputDir = options.output;
      }
      return mainCommand();
    }
  };

  mainCommand = function() {
    var completeSync, initCompileWidgets;
    if (!testCommandDir()) {
      return false;
    }
    if (options.clean) {
      removeDirSync(outputDir);
    }
    _startTimer();
    createDir(outputDir, function(existDir) {
      if (!existDir) {
        Cordjs.utils.timeLog("Output directory created '" + outputDir + "'");
      }
      aFiles.sync = [];
      aFiles.compile = [];
      basePath = path.normalize(publicDir);
      return syncFiles(publicDir, basePath, function() {
        return exec("sass --update " + publicDir + ":" + (path.join(outputDir, publicDir)), function(error) {
          if (error != null) {
            Cordjs.utils.timeLogError('Sass compiler');
          }
          if (options.build) {
            return syncFiles('node_modules', path.normalize('node_modules'), completeSync);
          }
          return completeSync();
        });
      });
    });
    completeSync = function() {
      return syncFiles('server.coffee', '.', function() {
        return initCompileWidgets(function() {
          var countCompiled;
          countCompiled = (aFiles.compile.length ? ("" + aFiles.compile.length).green : ("" + aFiles.compile.length).grey);
          Cordjs.utils.timeLog("Sync files is complete! Total " + ("" + aFiles.sync.length).yellow + (" files, " + countCompiled + " files compiled"));
          if (!options.clean && aFiles.compile.length) {
            Cordjs.utils.timeLog("Compiled files: " + ("" + (aFiles.compile.join(', '))).yellow);
          }
          options.started = true;
          _endTimer();
          if (options.server) {
            pathToNodeInit = "" + (path.join(baseDirFull, outputDir, publicDir, pathToNodeInit));
            return startServer();
          }
        });
      });
    };
    return initCompileWidgets = function(callback) {
      var baseUrl, configPaths;
      if (!options.build && !options.dev) {
        return typeof callback === "function" ? callback() : void 0;
      }
      configPaths = require("" + (path.join(baseDirFull, outputDir, publicDir, pathToCore)) + "configPaths");
      baseUrl = path.join(outputDir, publicDir);
      requirejs.config({
        baseUrl: baseUrl,
        nodeRequire: require
      });
      requirejs.config(configPaths);
      return requirejs(["cord!config"], function(config) {
        config.PUBLIC_PREFIX = baseUrl;
        return compileWidget(callback);
      });
    };
  };

  testCommandDir = function() {
    try {
      baseDirFull = path.dirname(fs.realpathSync(publicDir));
      return true;
    } catch (e) {
      if (e.code === 'ENOENT') {
        Cordjs.utils.timeLog("Error: no such public directory '" + publicDir + "'");
      }
      return false;
    }
  };

  createDir = function(dir, callback) {
    var dirFull;
    try {
      dirFull = path.dirname(fs.realpathSync(dir));
      return typeof callback === "function" ? callback(dirFull) : void 0;
    } catch (e) {
      if (e.code === 'ENOENT') {
        return Cordjs.sendCommand("mkdir -p " + dir, function(error) {
          if (error) {
            util.print(error);
          }
          return typeof callback === "function" ? callback() : void 0;
        });
      }
    }
  };

  getWidgetPath = function(source) {
    var pathToWidget, widgetClassName;
    source = path.dirname(source);
    source = source.replace('public/bundles', '');
    source = source.replace('/widgets/', '//');
    widgetClassName = path.basename(source);
    widgetClassName = widgetClassName.charAt(0).toUpperCase() + widgetClassName.slice(1);
    pathToWidget = source.split('/');
    pathToWidget.pop();
    return "" + (pathToWidget.join('/')) + "/" + widgetClassName;
  };

  addWidgetWaitCompiler = function(source) {
    var dirname;
    if (parseInt(source.indexOf('/widgets/')) < 0) {
      return;
    }
    dirname = getWidgetPath(source);
    if (widgetsWaitComliler.some(function(s) {
      return s.indexOf(dirname) >= 0;
    })) {
      return;
    }
    if (isDiffSource(path.dirname(source), outputPath(path.dirname(source), basePath))) {
      return widgetsWaitComliler.push(dirname);
    }
  };

  compileWidget = function(callback) {
    var widgetName,
      _this = this;
    widgetName = widgetsWaitComliler.pop();
    if (!(widgetName != null)) {
      return typeof callback === "function" ? callback() : void 0;
    }
    return requirejs(["cord-w!" + widgetName, "cord!widgetCompiler", "cord!config"], function(WidgetClass, widgetCompiler, config) {
      var widget;
      widget = new WidgetClass(true);
      widgetCompiler.reset(widget);
      return widget.compileTemplate(function(err, output) {
        var outputSource, source;
        if (err) {
          throw err;
        }
        source = "" + publicDir + "/bundles/" + (widget.getTemplatePath()) + ".structure.json";
        outputSource = outputPath(source, path.normalize(publicDir));
        return fs.writeFile(outputSource, widgetCompiler.getStructureCode(false), function(err) {
          var _this = this;
          fs.stat(path.dirname(source), function(err, stat) {
            return fs.utimes(path.dirname(outputSource), stat.atime, stat.mtime);
          });
          return compileWidget(callback);
        });
      });
    });
  };

  otherCommand = function(type, command, args) {
    if (Cordjs.Generator.exists(type)) {
      return Cordjs.Generator["do"](type, command, args);
    } else {
      return console.log("Generator " + type + " not found. Available generators: " + (Cordjs.Generator.list()));
    }
  };

  create = function(type) {
    type = type.shift();
    if (!(type != null)) {
      return console.log('What create: app or bundle?');
    } else if (!Cordjs.creator.exist(type)) {
      return console.log("Generator " + type + " not found");
    }
  };

  startServer = function() {
    serverChild = spawn("node", [path.join(outputDir, 'server.js'), path.join(outputDir, publicDir)]);
    serverChild.stdout.on('data', function(data) {
      return util.print(data);
    });
    return serverChild.stderr.on('data', function(error) {
      return util.print(error);
    });
  };

  stopServer = function() {
    return serverChild != null ? serverChild.kill() : void 0;
  };

  restartServer = function() {
    stopServer();
    startServer();
    return Cordjs.utils.timeLog('Server restarted');
  };

  syncFiles = function(source, base, callback) {
    return fs.stat(source, function(err, stats) {
      var walker;
      if (stats.isFile()) {
        return syncFile(source, base, function() {
          aFiles.sync.push(source);
          return typeof callback === "function" ? callback() : void 0;
        });
      }
      walker = walk.walk(source, {
        followLinks: false
      });
      walker.on('directory', function(root, stat, next) {
        source = path.join(root, stat.name);
        if (hidden(source)) {
          return next();
        }
        if (options.watch) {
          watchDir(source, base);
        }
        return next();
      });
      walker.on('file', function(root, stat, next) {
        source = path.join(root, stat.name);
        if (hidden(source)) {
          return next();
        }
        syncFile(source, base, function() {
          aFiles.sync.push(source);
          return next();
        });
        return next();
      });
      walker.on('symbolicLink', function(root, stat, next) {
        var dirname, symbolicLink;
        symbolicLink = path.join(root, stat.name);
        dirname = path.dirname(symbolicLink);
        source = path.join(dirname, fs.readlinkSync(symbolicLink));
        if (hidden(symbolicLink)) {
          return next();
        }
        syncFile(source, base, function() {
          aFiles.sync.push(source);
          return next();
        }, false, symbolicLink);
        return next();
      });
      return walker.on('end', function() {
        return typeof callback === "function" ? callback() : void 0;
      });
    });
  };

  syncFile = function(source, base, callback, onlyWatch, symbolicLink) {
    var baseSource, completeSync, extname;
    if (onlyWatch == null) {
      onlyWatch = false;
    }
    baseSource = (symbolicLink ? symbolicLink : source);
    if (!onlyWatch) {
      sources.push(baseSource);
    }
    if (!onlyWatch && options.watch) {
      watchFile(baseSource, base, symbolicLink);
    }
    extname = path.extname(baseSource);
    if (onlyWatch && parseInt(source.indexOf('/widgets/')) > 0) {
      widgetsWaitComliler.push(getWidgetPath(source));
    }
    completeSync = function() {
      if (!options.started) {
        return typeof callback === "function" ? callback() : void 0;
      }
      return compileWidget(callback);
    };
    if (extname === ".scss" || extname === ".sass") {
      if (!options.started) {
        aFiles.compile.push(source);
        return completeSync();
      }
      return exec("sass --update " + (path.dirname(outputPath(baseSource, base))) + ":" + source, function(error) {
        if (error != null) {
          Cordjs.utils.timeLogError("Sass: " + source);
        } else {
          Cordjs.utils.timeLog("Update Saas '" + source + "'");
        }
        return completeSync();
      });
    } else if (options.dev || options.build) {
      return copyFile(source, base, function(err) {
        addWidgetWaitCompiler(baseSource);
        return completeSync();
      }, symbolicLink);
    } else {
      return completeSync();
    }
  };

  copyFile = function(source, base, callback, symbolicLink) {
    var copyCallback, copyHelper, fileDir, filePath, sourceStat;
    filePath = outputPath((symbolicLink ? symbolicLink : source), base);
    fileDir = path.dirname(filePath);
    sourceStat = null;
    copyCallback = function() {
      var _this = this;
      aFiles.compile.push(source);
      fs.utimes(filePath, sourceStat.atime, sourceStat.mtime, callback);
      fs.stat(path.dirname(source), function(err, stat) {
        return fs.utimes(fileDir, stat.atime, stat.mtime);
      });
      if (options.started && options.watch) {
        return Cordjs.utils.timeLog("Update file '" + source + "'");
      }
    };
    copyHelper = function() {
      var _this = this;
      return fs.stat(source, function(err, stat) {
        sourceStat = stat;
        if (err) {
          if (typeof callback === "function") {
            callback(err);
          }
        }
        if (!isDiffSource(source, filePath)) {
          return typeof callback === "function" ? callback() : void 0;
        }
        if (path.extname(source) === '.coffee') {
          return CoffeeScript.compile(source, base, options, function(jsCode) {
            return fs.writeFile(filePath, jsCode, function(err) {
              if (err) {
                printLine(err.message);
              }
              return copyCallback();
            });
          });
        } else {
          return util.pump(fs.createReadStream(source), fs.createWriteStream(filePath), function(err) {
            if (err != null) {
              return typeof callback === "function" ? callback(err) : void 0;
            }
            return copyCallback();
          });
        }
      });
    };
    return exists(fileDir, function(itExists) {
      if (itExists) {
        return copyHelper();
      } else {
        return exec("mkdir -p " + fileDir, copyHelper);
      }
    });
  };

  isDiffSource = function(baseSource, outputSource, baseStat, outputStat) {
    if (!(baseStat != null)) {
      baseStat = fs.statSync(baseSource);
    }
    try {
      if (!(outputStat != null)) {
        outputStat = fs.statSync(outputSource);
      }
      if (outputStat.isDirectory() || path.extname(baseSource) === '.coffee') {
        if (baseStat.mtime.getTime() === outputStat.mtime.getTime()) {
          return false;
        }
      } else {
        if (outputStat.size === baseStat.size && baseStat.mtime.getTime() === outputStat.mtime.getTime()) {
          return false;
        }
      }
    } catch (_error) {}
    return true;
  };

  watchFile = function(source, base, symbolicLink) {
    var prevStats, rewatch, sync, syncTimeout, watchErr, watcher;
    prevStats = null;
    syncTimeout = null;
    watchErr = function(e) {
      if (e.code === 'ENOENT') {
        if (sources.indexOf(source) === -1) {
          return;
        }
        try {
          rewatch();
          return sync();
        } catch (e) {
          removeSource(source, base, true);
          return Cordjs.utils.timeLog("Remove file '" + source + "'");
        }
      } else {
        if (e.code === 'EMFILE') {
          Cordjs.utils.timeLogError("Max limit opened files. Try change limit. " + 'For mac use: ulimit -n 65536'.yellow);
        }
        throw e;
      }
    };
    sync = function() {
      clearTimeout(syncTimeout);
      return syncTimeout = wait(25, function() {
        return fs.stat(source, function(err, stats) {
          if (err) {
            return watchErr(err);
          }
          if (prevStats && stats.size === prevStats.size && stats.mtime.getTime() === prevStats.mtime.getTime()) {
            return rewatch();
          }
          prevStats = stats;
          return syncFile(source, base, function() {
            if (options.server) {
              restartServer();
            }
            return rewatch();
          }, true, symbolicLink);
        });
      });
    };
    try {
      watcher = fs.watch(source, sync);
    } catch (e) {
      watchErr(e);
    }
    return rewatch = function() {
      if (watcher != null) {
        watcher.close();
      }
      return watcher = fs.watch(source, sync);
    };
  };

  watchDir = function(source, base) {
    var readdirTimeout, watcher;
    readdirTimeout = null;
    try {
      return watcher = fs.watch(source, function() {
        clearTimeout(readdirTimeout);
        return readdirTimeout = wait(25, function() {
          return fs.readdir(source, function(err, files) {
            var file, _i, _len, _results;
            if (err) {
              if (err.code !== 'ENOENT') {
                throw err;
              }
              watcher.close();
              return unwatchDir(source, base);
            }
            _results = [];
            for (_i = 0, _len = files.length; _i < _len; _i++) {
              file = files[_i];
              file = path.join(source, file);
              if (sources.some(function(s) {
                return s.indexOf(file) >= 0;
              })) {
                continue;
              }
              if (hidden(file)) {
                continue;
              }
              Cordjs.utils.timeLog("Add file '" + file + "'");
              sources.push(file);
              _results.push(syncFiles(file, base));
            }
            return _results;
          });
        });
      });
    } catch (e) {
      if (e.code !== 'ENOENT') {
        throw e;
      }
    }
  };

  unwatchDir = function(source, base) {
    var file, prevSources, toRemove, _i, _len;
    prevSources = sources.slice(0);
    toRemove = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = sources.length; _i < _len; _i++) {
        file = sources[_i];
        if (file.indexOf(source) >= 0) {
          _results.push(file);
        }
      }
      return _results;
    })();
    for (_i = 0, _len = toRemove.length; _i < _len; _i++) {
      file = toRemove[_i];
      removeSource(file, base, true);
    }
    if (!sources.some(function(s, i) {
      return prevSources[i] !== s;
    })) {

    }
  };

  removeSource = function(source, base, remove) {
    var index, outPath;
    index = sources.indexOf(source);
    sources.splice(index, 1);
    if (remove) {
      outPath = outputPath(source, base);
      return exists(outPath, function(itExists) {
        if (itExists) {
          return fs.unlink(outPath, function(err) {
            if (err && err.code !== 'ENOENT') {
              throw err;
            }
            return Cordjs.utils.timeLog("removed " + source);
          });
        }
      });
    }
  };

  removeDirSync = function(source) {
    var file, filename, stat, _i, _len, _ref1;
    try {
      _ref1 = fs.readdirSync(source);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        file = _ref1[_i];
        filename = path.join(source, file);
        stat = fs.statSync(filename);
        if (filename === "." || filename === "..") {
          continue;
        }
        if (stat.isDirectory()) {
          removeDirSync(filename);
        } else {
          fs.unlinkSync(filename);
        }
      }
      return fs.rmdirSync(source);
    } catch (e) {
      if (e.code !== 'ENOENT') {
        throw e;
      }
    }
  };

  outputPath = function(source, base) {
    var baseDir, dir, filename, srcDir;
    filename = path.basename(source);
    if (path.extname(source) === '.coffee') {
      filename = path.basename(source, path.extname(source)) + '.js';
    }
    srcDir = path.dirname(source);
    baseDir = srcDir;
    dir = path.join(outputDir, baseDir);
    return path.join(dir, filename);
  };

  parseOptions = function(args) {
    var o, optionParser;
    optionParser = new optparse.OptionParser(OptionsList, EmptyArguments);
    o = options = optionParser.parse(args);
    if (options.autorestart) {
      options.server = options.watch = true;
    }
    options.started = false;
    if (o["arguments"].length) {
      return publicDir = o["arguments"][0];
    }
  };

  usage = function() {
    return printLine((new optparse.OptionParser(OptionsList, EmptyArguments)).help());
  };

  version = function() {
    return printLine("Cordjs current version: " + Cordjs.VERSION.green);
  };

  _startTimer = function() {
    return timeStart = new Date();
  };

  _endTimer = function() {
    timeEnd = new Date();
    return Cordjs.utils.timeLog("Timer: " + (timeEnd - timeStart) + " milliseconds");
  };

  wait = function(milliseconds, func) {
    return setTimeout(func, milliseconds);
  };

  exists = fs.exists || path.exists;

  hidden = function(file) {
    return /\/\.|~$/.test(file) || /^\.|~$/.test(file);
  };

  printLine = function(line) {
    return process.stdout.write(line + '\n');
  };

  printWarn = function(line) {
    return process.stderr.write(line + '\n');
  };

}).call(this);
