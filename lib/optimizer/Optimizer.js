// Generated by CoffeeScript 1.6.3
var ByWidgetGroupDetector, CorrelationGroupDetector, Future, GroupRepo, HeuristicGroupDetector, Optimizer, fs, mkdirp, sha1, _;

fs = require('fs');

_ = require('underscore');

mkdirp = require('mkdirp');

Future = require('../utils/Future');

sha1 = require('../utils/sha1');

ByWidgetGroupDetector = require('./ByWidgetGroupDetector');

CorrelationGroupDetector = require('./CorrelationGroupDetector');

GroupRepo = require('./GroupRepo');

HeuristicGroupDetector = require('./HeuristicGroupDetector');

Optimizer = (function() {
  function Optimizer() {}

  Optimizer.prototype.run = function() {
    var statFile,
      _this = this;
    statFile = 'require-stat.json';
    return fs.readFile(statFile, function(err, data) {
      var stat;
      stat = err ? {} : JSON.parse(data);
      return console.log(JSON.stringify(_this.generateOptimizationMap(stat), null, 2));
    });
  };

  Optimizer.prototype.generateOptimizationMap = function(stat) {
    var corrDetector, group, groupId, groupRepo, groups, heuristicDetector, iterations, page, resultMap, widgetDetector, _i, _len;
    iterations = 1;
    groupRepo = new GroupRepo;
    widgetDetector = new ByWidgetGroupDetector(groupRepo);
    stat = widgetDetector.process(stat);
    while (iterations--) {
      corrDetector = new CorrelationGroupDetector(groupRepo);
      stat = corrDetector.process(stat);
      heuristicDetector = new HeuristicGroupDetector(groupRepo);
      stat = heuristicDetector.process(stat);
    }
    resultMap = {};
    for (page in stat) {
      groups = stat[page];
      for (_i = 0, _len = groups.length; _i < _len; _i++) {
        groupId = groups[_i];
        group = groupRepo.getGroup(groupId);
        if (group) {
          resultMap[groupId] = _.uniq(group.getModules());
        }
      }
    }
    this._mergeGroups(resultMap);
    return resultMap;
  };

  Optimizer.prototype._mergeGroups = function(groupsMap) {
    var groupId, modules, result;
    result = {};
    for (groupId in groupsMap) {
      modules = groupsMap[groupId];
      result[groupId] = this._mergeGroup(modules);
    }
    return result;
  };

  Optimizer.prototype._mergeGroup = function(modules) {
    var futures, mergedContent, module;
    mergedContent = '';
    futures = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = modules.length; _i < _len; _i++) {
        module = modules[_i];
        _results.push((function(module) {
          return Future.call(fs.readFile, "target/public/" + module + ".js", 'utf8').map(function(js) {
            js = js.replace('define(', "define('" + module + "',");
            mergedContent += js + "\n\n";
            return true;
          }).mapFail(function() {
            return false;
          });
        })(module));
      }
      return _results;
    })();
    return Future.call(mkdirp, 'target/public/assets/z').zip(Future.sequence(futures)).flatMap(function() {
      return Future.call(fs.writeFile, "target/public/assets/z/" + (sha1(mergedContent)) + ".js", mergedContent);
    });
  };

  return Optimizer;

})();

module.exports = Optimizer;
