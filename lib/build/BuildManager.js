// Generated by CoffeeScript 1.6.3
var BuildManager, BuildWorkerManager, Future, os, _;

_ = require('underscore');

os = require('os');

Future = require('../utils/Future').Future;

BuildWorkerManager = require('./BuildWorkerManager').BuildWorkerManager;

BuildManager = (function() {
  /*
  Build worker process manager and load balancer for the build tasks
  @static
  */

  function BuildManager() {}

  BuildManager.workers = [];

  BuildManager.MAX_WORKERS = Math.max(os.cpus().length, 2);

  BuildManager._taskIdCounter = 0;

  BuildManager.createTask = function(relativeFilePath, baseDir, targetDir) {
    var _this = this;
    return this.findBestWorker().flatMap(function(worker) {
      return worker.addTask({
        id: ++_this._taskIdCounter,
        file: relativeFilePath,
        baseDir: baseDir,
        targetDir: targetDir
      });
    });
  };

  BuildManager.findBestWorker = function() {
    /*
    Chooses best worker process (less loaded) for the next file.
    @return Future[Worker]
    */

    var emptyWorker, freeWorkers, newWorker, recursiveWait, result, sorted,
      _this = this;
    result = Future.single();
    emptyWorker = _.find(this.workers, function(w) {
      return w.getWorkload() === 0;
    });
    if (emptyWorker) {
      result.resolve(emptyWorker);
    } else {
      if (this.workers.length < this.MAX_WORKERS) {
        newWorker = new BuildWorkerManager(this);
        this.workers.push(newWorker);
        result.resolve(newWorker);
      } else {
        freeWorkers = _.filter(this.workers, function(w) {
          return w.canAcceptTask();
        });
        if (freeWorkers.length) {
          sorted = _.sortBy(freeWorkers, function(w) {
            return w.getWorkload();
          });
          result.resolve(sorted[0]);
        } else {
          recursiveWait = function() {
            return Future.select(_.map(_this.workers, function(w) {
              return w.acceptReady();
            })).done(function(worker) {
              if (worker.canAcceptTask()) {
                return result.resolve(worker);
              } else {
                return recursiveWait();
              }
            });
          };
          recursiveWait();
        }
      }
    }
    return result;
  };

  BuildManager.stopWorker = function(worker) {
    this.workers = _.without(this.workers, worker);
    return console.log("Worker " + worker.id + " stopped. Total tasks count: " + worker.totalTasksCount);
  };

  return BuildManager;

})();

exports.buildManager = BuildManager;
