// Generated by CoffeeScript 1.6.3
var EventEmitter, Future, ProjectWatcher, fs, path, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

path = require('path');

fs = require('fs');

_ = require('underscore');

EventEmitter = require('events').EventEmitter;

Future = require('../utils/Future');

ProjectWatcher = (function(_super) {
  __extends(ProjectWatcher, _super);

  /*
  Directory tree watcher wrapper.
  Emits aggregated 'change' event when some watched files/directories are added/removed/moved
  */


  ProjectWatcher.prototype._watchTree = null;

  ProjectWatcher.prototype._fileByInode = null;

  ProjectWatcher.prototype._inodeByFile = null;

  ProjectWatcher.prototype._analyzeList = null;

  ProjectWatcher.prototype._aggregateTimeout = null;

  ProjectWatcher.prototype._previousAnalyzeAndEmit = null;

  function ProjectWatcher(baseDir) {
    var rootInfo;
    this.baseDir = baseDir;
    rootInfo = {
      dir: this.baseDir,
      watchAll: false,
      children: {},
      contents: null,
      watcher: null
    };
    this._watchTree = rootInfo;
    this._analyzeList = {};
    this._previousAnalyzeAndEmit = Future.resolved();
  }

  ProjectWatcher.prototype.addDir = function(dir) {
    var curParent, part, parts, _i, _len;
    if (dir.indexOf(this.baseDir) === 0) {
      parts = dir.substr(this.baseDir.length).split(path.sep);
      parts = _.compact(parts);
      curParent = this._watchTree;
      for (_i = 0, _len = parts.length; _i < _len; _i++) {
        part = parts[_i];
        curParent = this._watchDir(curParent, part);
      }
      return curParent.watchAll = true;
    } else {
      throw new Error("Watch directory " + dir + " must be sub-directory of base dir " + this.baseDir + "!");
    }
  };

  ProjectWatcher.prototype._watchDir = function(parentInfo, localName) {
    var dir, watchInfo,
      _this = this;
    if (parentInfo.children[localName] != null) {
      return parentInfo.children[localName];
    } else {
      dir = path.join(parentInfo.dir, localName);
      watchInfo = {
        dir: dir,
        watchAll: false,
        children: {},
        contents: this._readdir(dir),
        watcher: fs.watch(dir, function(event, filename) {
          return _this._handleDir(watchInfo, filename, event);
        })
      };
      parentInfo.children[localName] = watchInfo;
      return watchInfo;
    }
  };

  ProjectWatcher.prototype._readdir = function(dir) {
    /*
    Collects stat-info of all shallow members of the given directory.
    @param String dir absolute directory path
    @return Future[Map[String -> StatInfo]]
    */

    return Future.call(fs.readdir, dir).flatMap(function(dirList) {
      var fList, name;
      fList = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = dirList.length; _i < _len; _i++) {
          name = dirList[_i];
          _results.push((function(name) {
            return Future.call(fs.lstat, path.join(dir, name)).map(function(stat) {
              stat.name = name;
              return stat;
            });
          })(name));
        }
        return _results;
      })();
      return Future.sequence(fList).map(function(statList) {
        var result, stat, _i, _len;
        result = {};
        for (_i = 0, _len = statList.length; _i < _len; _i++) {
          stat = statList[_i];
          result[stat.name] = stat;
        }
        return result;
      });
    });
  };

  ProjectWatcher.prototype._handleDir = function(watchInfo, filename, event) {
    console.log("watch event", event, filename, watchInfo.dir);
    return this._analyzeDir(watchInfo);
  };

  ProjectWatcher.prototype._analyzeDir = function(watchInfo) {
    /*
    Collects directories to be analyzed together to emit one 'change' event
    */

    this._analyzeList[watchInfo.dir] = watchInfo;
    return this._activateAggregateTimeout();
  };

  ProjectWatcher.prototype._activateAggregateTimeout = function() {
    var _this = this;
    if (this._aggregateTimeout != null) {
      clearTimeout(this._aggregateTimeout);
    }
    return this._aggregateTimeout = setTimeout(function() {
      var current, previous, tmpList;
      tmpList = _this._analyzeList;
      _this._analyzeList = {};
      _this._aggregateTimeout = null;
      previous = _this._previousAnalyzeAndEmit;
      current = Future.single();
      _this._previousAnalyzeAndEmit = current;
      return previous.done(function() {
        return current.when(_this._analyzeAndEmit(tmpList));
      });
    }, 100);
  };

  ProjectWatcher.prototype._analyzeAndEmit = function(dirList) {
    /*
    Analyzes list of directories by diffing their current contents with the saved previous contents and
     emits appropriate 'change' event consumed by project builder
    @param Map[String -> Object]
    @return Future
    */

    var dir, result, watchInfo, _fn,
      _this = this;
    result = new Future;
    _fn = function(dir, watchInfo) {
      var newContents, oldContents;
      result.fork();
      newContents = _this._readdir(dir);
      oldContents = watchInfo.contents;
      watchInfo.contents = newContents;
      return oldContents.zip(newContents).done(function(oldMap, newMap) {
        var addList, changeList, changeMap, name, newItems, newStat, oldItems, oldStat, removeList, removeListFiltered, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
        oldItems = Object.keys(oldMap);
        newItems = Object.keys(newMap);
        removeList = _.difference(oldItems, newItems);
        addList = _.difference(newItems, oldItems);
        changeList = [];
        _ref = _.intersection(newItems, oldItems);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          name = _ref[_i];
          newStat = newMap[name];
          oldStat = newMap[name];
          if (newStat.mtime.getTime() !== oldStat.mtime.getTime()) {
            if ((newStat.isDirectory() && !oldStat.isDirectory()) || (!newStat.isDirectory() && oldStat.isDirectory())) {
              removeList.push(name);
              addList.push(name);
            } else if (!newStat.isDirectory() && !oldStat.isDirectory()) {
              changeList.push(name);
            }
          }
        }
        changeMap = {};
        if (watchInfo.watchAll) {
          _ref1 = addList.concat(changeList);
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            name = _ref1[_j];
            changeMap[path.join(dir, name)] = newMap[name];
          }
        }
        removeListFiltered = [];
        for (_k = 0, _len2 = removeList.length; _k < _len2; _k++) {
          name = removeList[_k];
          if (watchInfo.watchAll || (watchInfo.children[name] != null)) {
            if (watchInfo.children[name] != null) {
              _this._stopWatching(watchInfo.children[name]);
            }
            removeListFiltered.push(path.join(dir, name));
          }
        }
        if (Object.keys(changeMap).length > 0 || removeList.length > 0) {
          _this.emit('change', {
            removed: removeListFiltered,
            changed: changeMap
          });
        }
        return result.resolve();
      }).fail(function(err) {
        if (err.code === 'ENOENT') {
          _this._stopWatching(watchInfo);
          return result.resolve();
        } else {
          console.error("ERROR: readdir failed", watchInfo, err);
          throw err;
        }
      });
    };
    for (dir in dirList) {
      watchInfo = dirList[dir];
      _fn(dir, watchInfo);
    }
    return result;
  };

  ProjectWatcher.prototype._stopWatching = function(watchInfo) {
    var child, name, _ref, _ref1;
    if ((_ref = watchInfo.watcher) != null) {
      _ref.close();
    }
    watchInfo.watcher = null;
    _ref1 = watchInfo.children;
    for (name in _ref1) {
      child = _ref1[name];
      this._stopWatching(child);
    }
    return watchInfo.children = {};
  };

  return ProjectWatcher;

})(EventEmitter);

module.exports = ProjectWatcher;
